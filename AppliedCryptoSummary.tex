\documentclass[11pt,a4paper]{article}
\usepackage{plain}
\usepackage[english]{babel}
\usepackage{a4wide}

%\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsthm}

\usepackage [
n, adversary,landau,probability,notions,logic, ff, mm,
primitives,events,complexity,oracles,asymptotics,keys,sets,operators,advantage]{ cryptocode}
\renewcommand{\pcadvantagename}{\mathbf{Adv}}
\renewcommand{\pcadvantagesuperstyle}[1]{\mathrm{\MakeUppercase{#1}}}
\renewcommand{\pcalgostyle}[1]{\ensuremath{\textsc{#1}}}
\renewcommand{\pcoraclestyle}[1]{\mathrm{#1}}
\renewcommand{\verify}{\textsc{Vfy}}
\newcommand{\Tag}{\textsc{Tag}}
\newcommand{\PRP}{\text{PRP}}
\newcommand{\PRF}{\text{PRF}}
\newcommand{\SE}{\textsc{SE}}
\newcommand{\PKE}{\textsc{PKE}}
\newcommand{\KEM}{\textsc{KEM}}

%\usepackage{package}
\usepackage{framed}
\usepackage{hyperref}

%\usepackage[linesnumbered]{algorithm2e}
\usepackage{url}
\usepackage[shortlabels]{enumitem}
\usepackage[cal=cm,frak=euler,scr=boondox,bb=ams]{mathalfa}

%\usepackage{macros}
\usepackage{stmaryrd}
\usepackage{float}

\newtheorem{theorem}{Theorem}

% Some macro definitions might come in handy
%\newcommand{\sample}[0]{\leftarrow_\$}
%\newcommand{\rsample}[0]{\rightarrow_\$}

\usepackage{dashbox}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Begain Here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\begin{center}
\sc
\huge{Applied Cryptography} 

\vspace{0.5cm}
\Large{Lecture Note}

\vspace{0.5cm}
\large{Spring 2023}

\vspace{0.5cm}
\large{Cao, Ganyuan}
\vspace{1cm}
\end{center}

\tableofcontents



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Security Proof}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Game-based Security Proof Framework}
To prove the statment: \textit{"If a scheme $\textsf{F}_1$ is $\mathcal{S}_1$ secure, then a scheme $\textsf{F}_2$ is $\mathcal{S}_2$ secure"}, we follow the steps:
\begin{enumerate}
	\item Suppose by contraposition that there is an adversary $\adv$ against $\mathcal{S}_2$ security of $\textsf{F}_2$ s.t. $\advantage{\mathcal{S}_2}{\textsf{F}_2}[(\adv)]$ is not negligible. 
	\item Construct the adversary $\bdv$ against $\mathcal{S}_1$ security of $\textsf{F}_1$ with $\adv$ as subroutine. 
	\item Deduce that $\advantage{\mathcal{S}_1}{\textsf{F}_1}[(\bdv)]$ is not negligible. 
\end{enumerate}

\textit{Remarks:}
\begin{enumerate}
	\item Assume that $\bdv$ is given an oracle $\oracle_{\bdv}$, we use $\oracle_{\bdv}$ to simulate the pre-defined oracle for $\oracle_\adv$. In the adversary $\bdv$, the adversary $\adv$ instead calls the simulation oracle $\oracle[OSim]_\adv$. 
	\item The adversary $\bdv$ together with the oracle $\oracle[OSim]_\adv$ simulates the $\mathcal{S}_2$ security game of $\textsf{F}_2$. 
	\item The framework also works for problem reduction. If we want to prove a problem $\mathcal{P}_1$ reduces to a problem $\mathcal{P}_2$, it is equivalent to prove \textit{"if there is an adversary that break the problem $\mathcal{P}_2$ with non-negligible advantage, then there is an adversary $\bdv$ that break $\mathcal{P}_1$ with non-negligible advantage."}
	\item In the case that the primitive $\mathcal{S}_1$ is too "far" from $\mathcal{S}_2$, and \textit{distinguishibility} game in involved, it is better to use "game-chaining" method by decomposing the distinguishibility game into sub-games and chain the sub-games to prove the advantage. Note that the framework proposed by Ballare can be used to write the games for better readability.  
\end{enumerate}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Advantage Rewriting Lemma}
Let $b$ be a uniformly random bit, $b'$ be the output of some algorithm. Then 
$$
\begin{aligned}
2 \abs{\Pr[b' = b] - \frac{1}{2}} 
&= \abs{\Pr[b' = 1 | b = 1] - \Pr[b' = 1 | b = 0] } \\
&= \abs{\Pr[b' = 0 | b = 0] - \Pr[b' = 0 | b = 1] }
\end{aligned}
$$

\begin{proof}
$$
\begin{aligned}
\Pr[b'=b] - \frac{1}{2} &= \Pr[b' = b \mid b = 1] \cdot \Pr[b=1] + \Pr[b'=b \mid b = 0] \cdot \Pr[b = 0] - \frac{1}{2} \\	
&=  \Pr[b' = b \mid b = 1] \cdot \frac{1}{2} + \Pr[b' = b \mid b = 0] \cdot \frac{1}{2} - \frac{1}{2} \\  
&= \frac{1}{2}(\Pr[b'=1 \mid b = 1] + \Pr[b' = 0 \mid b=0] - 1) \\
&= \frac{1}{2}(\Pr[b'=1 \mid b = 1] - (1 - \Pr[b' = 0 \mid b = 0])) \\
&= \frac{1}{2}(\Pr[b'=1 \mid b=1] - \Pr[b'=1 \mid b = 0])
\end{aligned}
$$

\end{proof}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The Difference Lemma}
Let $Z, W_1, W_2$ be (any) events defined over some probability space. Suppose that $\Pr[W_1 \wedge \neg Z] = \Pr[W_2 \wedge \neg Z]$. Then we have $\abs{\Pr[W_2] - \Pr[W_1] \leq \Pr[Z]}$. (In typical uses, we have that $(W_1 \wedge \neg Z)$ occurs if and only if $(W_2 \wedge Z)$ occurs)

\begin{proof}
$$
\begin{aligned}
\abs{\Pr[W_2] - \Pr[W_1]} &= \abs{\Pr[(W_1 \wedge Z) \vee (W_1 \wedge \neg Z)]  -\Pr[(W_2 \wedge Z) \vee (W_2 \wedge \neg Z)] } \\ 
&= \abs{\Pr[W_1 \wedge Z] + \Pr[W_1 \wedge \neg Z]  - \Pr[W_2 \wedge Z] - \Pr[W_2 \wedge \neg Z] } \\ 
&= \abs{\Pr[W_1 \wedge Z] - \Pr[W_2 \wedge Z]} \\
&\leq \Pr[Z]
\end{aligned}
$$
\end{proof}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Symmetric Encryption}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Symmetric Encryption}
A symmetric encryption scheme with key space $\mathcal{K}$, plaintext space $\mathcal{M}$, ciphertext space $\mathcal{C}$, consists of a triple of efficient algoritms: $\SE = (\kgen, \enc, \dec)$ where  
$$
\begin{aligned}
&\kgen: \{\} \rightarrow \mathcal{K} \\
&\enc: \mathcal{K} \times \mathcal{M} \rightarrow \mathcal{C} \\
&\dec: \mathcal{K} \times \mathcal{C} \rightarrow \mathcal{M} \cup \{\bot\}
\end{aligned}
$$
such that 
$$
\forall K \ \forall m, \dec_K(\enc_K(m)) = m
$$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Block Cipher}
A block cipher $E$ with key length $k$ and block size $n$ consists of a pair of efficiently computable permutations $(\mathcal{E}, \mathcal{D})$ where 
$$
\begin{aligned}
&\edv: \bin^n \times \bin^k \rightarrow \bin^n \\
&\ddv: \bin^n \times \bin^k \rightarrow \bin^n
\end{aligned}
$$ 
such that 
$$
\forall K \in \bin^k \ \forall m \in \bin^n, \ddv(K, \edv(K, m)) = m
$$




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Pseudorandom Permutation/Function}
\subsubsection{PRP Security}
A block cipher $E$ is defined to be $(q,t,\varepsilon)$ secure as a \textit{pseudorandom permutation} ($\prp$), if for any adversary $\adv$ running in time at most $t$ and making at most $q$ queries to $\mathcal{E}_K / \pi$, the advantage $\advantage{PRP}{E}[(\adv)] \leq \varepsilon$ where  

$$
\advantage{PRP}{E}[(\adv)] = 2 \cdot | \Pr[\textbf{Game } \PRP(\adv, E) \Rightarrow \true ] - \frac{1}{2} | 
$$ 


\begin{figure}[H]
\begin{pchstack}[ center , boxed, space=0.5cm]
\procedure[linenumbering]{$\textbf{Game } \PRP(\adv, E$)}{ 
b \sample \bin \\
K \sample \bin^k \\
\pi \sample \textsf{Perms}[\bin^n] \\
b' \sample \adv^{\oracle[RoR] }() \\
\pcreturn b'=b
 }

\procedure[linenumbering]{$\textbf{Oracle } \oracle[RoR](x)$}{ 
\pcif b = 0 \pcthen \\
\pcind y \leftarrow \mathcal{E}_K(x) \\
\pcelse \\
\pcind y \leftarrow \pi(x) \\
\pcreturn y
}
\end{pchstack}
\caption{PRP Game}
\label{fig:prp-game}
\end{figure}

\textit{Remark}:
\begin{enumerate}
	\item Subsaction of $\frac{1}{2}$ to measure how much better than random guessing the adversary $\adv$ does. 
	\item Scaling factor 2  turns the advantage into a number in the range $[0,1]$. 
	\item Here the oracle $\oracle[RoR]$ refers to "real or random". In the real world $(b=0)$, the block cipher $E$ is used. In ideal world $(b=1)$, a random permutation $\pi$ is used. 
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{PRF Security}
A block cipher  $E$ is defined to be $(q,t,\varepsilon)$-secure as a \textit{pseudorandom function} ($\prf$), if for any adversary $\adv$ running in time at most $t$ and making at most $q$ queries to $\mathcal{E}_K / \rho $, the advantage $\advantage{PRF}{E}[(\adv)] \leq \varepsilon$ where

$$
\advantage{\PRF}{E}[(\adv)] = 2 \cdot | \Pr[\textbf{Game } \PRF (\adv, E) \Rightarrow \true ] - \frac{1}{2} | 
$$ 


\begin{figure}[H]
\begin{pchstack}[ center , boxed, space=0.5cm]
\procedure[linenumbering]{$\textbf{Game }\PRF(\adv, E$)}{ 
b \sample \bin \\
K \sample \bin^k \\
\rho \sample \textsf{Funcs}[\bin^n] \\
b' \sample \adv^{\oracle[RoR] }() \\
\pcreturn b'=b
 }

\procedure[linenumbering]{$\textbf{Oracle }\oracle[RoR](x)$}{ 
\pcif b = 0 \pcthen \\
\pcind y \leftarrow \mathcal{E}_K(x) \\
\pcelse \\
\pcind y \leftarrow \rho(x) \\
\pcreturn y
}
\end{pchstack}
\caption{PRF Game}
\label{fig:prf-game}
\end{figure}

\textit{Remarks:}
\begin{enumerate}
\item A pseudorandom Function ($\prf$) is a function $\rho: \mathcal{K} \times \mathcal{D} \rightarrow \mathcal{R}$ defined over $(\mathcal{K},\mathcal{D},\mathcal{R})$ s.t. $\rho(k,x)$ can be evaluated efficiently. 
\item A pseudorandom Permutation ($\prp$) is a permutation $\pi: \mathcal{K} \times \mathcal{D} \rightarrow \mathcal{R}$ defined over $(\mathcal{K},\mathcal{D}, \mathcal{R})$ s.t. $\pi(k,x)$ can be evaluated efficiently; $\pi(k, \cdot)$ is injective; there exists an efficient inversion algorithm $\pi^{-1}$. 
\item The difference between a PRF and a PRP is that PRF does \textit{lazy sampling}. So a PRF may sample $y_i, y_j \in \mathcal{R}$ such that $y_i = y_j$ for some $i \neq j$. Suppose $q$ queries are made to a PRF, there are $\frac{q(q-1)}{2}$ such pairs and each happens with probability $\frac{1}{|\mathcal{R}|}$. Thus such event happens with probability $\frac{q(q-1)}{2|\mathcal{R}|}$. 
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{PRP-PRF Switching Lemma} Let $E$ be a bock cipher. Then for any adversary $\adv$ making $q$ queries,
$$
|\advantage{\PRP}{E}[(\adv)] - \advantage{\PRF}{E}[(\adv)]| \leq \frac{q^2}{2^{n+1}}
$$

\begin{proof}
Let $\adv$ be an $(q,t,\varepsilon)$ adversary that plays the game $\mathrm{G}_0 - \mathrm{G}_2$ in Figure \ref{fig:prp-prf-switching-lemma}. 
We have that $\mathrm{G}_0 = \mathrm{G}^{\PRP}_E = \mathrm{G}^{\PRF}_E $,  $\mathrm{G}_1 = \mathrm{G}^{\PRP}_\pi$, $\mathrm{G}_2 = \mathrm{G}^{\PRF}_\rho$. 
Thus we have that 
$$
\advantage{\PRP}{E}[(\adv)] = \Pr[\mathrm{G}_0(\adv)] - \Pr[\mathrm{G}_1(\adv)]
$$
and 
$$
\advantage{\PRF}{E}[(\adv)] = \Pr[\mathrm{G}_0(\adv)] - \Pr[\mathrm{G}_2(\adv)]
$$
Hence, 
$$
\abs{\advantage{\PRP}{E}[(\adv)] -  \advantage{\PRF}{E}[(\adv)]}  \leq \abs{\Pr[\mathrm{G}_2(\adv)] - \Pr[\mathrm{G}_1(\adv)]}
$$
We have that $\mathrm{G}_1$ and $\mathrm{G}_2$ are identical unless a repeated value occurs amongst the output values in $\mathrm{G}_2$. Consider that in game $\mathrm{G}_2$, the adversary queries $q$ times. Thus we need to sample $q$ output values $y_i$ uniformly at random from $\bin^n$. Thus $\Pr[y_i = y_j] = 2^{-n}$ for each pair of $(i,j)$. There are $\frac{q(q-1)}{2} \leq \frac{q^2}{2}$ pairs of indices. By union bound, we have that 
$$
\Pr[y_i = y_j \text{ for some } i \neq j ] \leq \frac{q^2}{2}
 \cdot 2^{-n} = \frac{q^2}{2^{n+1}}
 $$
 By the Difference Lemma, we have that 
 $$
 \begin{aligned}
 \abs{\advantage{\PRP}{E}[(\adv)] -  \advantage{\PRF}{E}[(\adv)]} &\leq \abs{\Pr[\mathrm{G}_2(\adv)] - \Pr[\mathrm{G}_1(\adv)]} \\
 &\leq \frac{q^2}{2^{n+1}}
 \end{aligned}
 $$

\end{proof}


\begin{figure}[H]
	\begin{pchstack}[ center , boxed, space=0.5cm]
	\procedure[linenumbering]{$\textbf{Game } \mathrm{G}_0$}{ 
		\textbf{procedure } \textsc{Init} \\
			\t K \sample \mathcal{K} \\
		\textbf{procedure } \oracle[OEnc](m) \\
			\t \pcreturn E(K, m)
	}
		
	\procedure[linenumbering]{$\textbf{Game } \mathrm{G}_1$}{ 
		\textbf{procedure } \textsc{Init} \\
			\t \pi \sample \mathcal{P}[\bin^n] \\
		\textbf{procedure } \oracle[OEnc](m) \\
			\t \pcreturn \pi(m)
	}
	
	\procedure[linenumbering]{$\textbf{Game } \mathrm{G}_1$}{ 
		\textbf{procedure } \textsc{Init} \\
			\t \rho \sample \mathcal{F}[\bin^n] \\
		\textbf{procedure } \oracle[OEnc](m) \\
			\t \pcreturn \rho(m)
	}
	
	
	\end{pchstack}
	\caption{Proof of PRP/PRF Switching Lemma}
\label{fig:prp-prf-switching-lemma}
\end{figure}



\textit{Remark}:
This leads to the following game that on an adversary's distinguishibility between a pseudorandom permutation and a pseudorandom function. The advantage is 

$$
\advantage{\prp / \prf}{}[(\adv)] = \frac{q^2}{2^{n+1}}
$$

\begin{figure}[H]
\begin{pchstack}[ center , boxed, space=0.5cm]
\procedure[linenumbering]{$\textbf{Game }\prp / \prf(\adv)$}{ 
b \sample \bin \\
K \sample \mathcal{K} \\
\Pi \sample \textsf{Perms}[\bin^n] \\
F \sample \textsf{Funcs}[\bin^n] \\
b' \sample \adv^{\oracle[LoR] }() \\
\pcreturn b'=b
 }

\procedure[linenumbering]{$\textbf{Oracle }\oracle[LoR](x)$}{ 
\pcif b = 0 \pcthen \\
\pcind y \leftarrow \Pi(x) \\
\pcelseif b = 1 \pcthen \\
\pcind y \leftarrow F(x) \\
\pcreturn y
}
\end{pchstack}
\caption{PRP / PRF Game}
\label{fig:prp-prf-game}
\end{figure}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Ciphertext/Plaintext Integrity}
\subsubsection{INT-CTXT Security}
A symmetric encryption scheme $\SE$ is said to be $(q_e, t, \varepsilon)$-\textit{ciphertext integrity} (INT-CTXT) secure, if for any adversary $\adv$ running in time $t$ and making at most $q_e$ encryption oracle queries and exact one try query to oracle $\oracle[OTry]$,  the advantage $\advantage{INT-CTXT}{\SE}[(\adv)] \leq \varepsilon$ where 
$$
\advantage{INT-CTXT}{\SE}[(\adv)] = \Pr[\textbf{Game } \text{INT-CTXT} \Rightarrow 1]
$$

\begin{figure}[H]
\begin{pchstack}[ center , boxed, space=0.5cm]
\procedure[linenumbering]{$\textbf{Game } \text{INT-CTXT}(\adv, \SE)$}{ 
K \sample \kgen(1^\lambda) \\
\mathcal{Q} \gets \emptyset \\
\adv^\oracle[OEnc, OTry]() \\
\pcreturn \textsf{win}
}

\begin{pcvstack}[space = 0.3cm]
\procedure[linenumbering]{$\textbf{Oracle }\oracle[OEnc](m)$}{ 
c \gets \enc(K, m) \\
\mathcal{Q} \gets \mathcal{Q} \cup \{c\} \\
\pcreturn c
}

\procedure[linenumbering]{$\textbf{Oracle }\oracle[OTry](c^*)$}{ 
\textsf{win} \gets 0 \\
m^* \gets \dec(K, c^*) \\
\pcif c^* \not\in \mathcal{Q} \wedge m^* \neq \bot \pcthen \\
\t \textsf{win} \gets 1
}
\end{pcvstack}
\end{pchstack}
\caption{INT-CTXT Game}
\label{fig:int-ctxt-game}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{INT-PTXT Security}
A symmetric encryption scheme $\SE$ is said to be $(q_e, t, \varepsilon)$-\textit{plaintext integrity} (INT-PTXT) secure if for all adversary $\adv$ running in time $t$ and making at most $q_e$ encryption oracle queries with $\advantage{INT-PTXT}{\SE}[(\adv)] \leq \varepsilon$ where 
$$
\advantage{INT-PTXT}{\textsf{SE}}[(\adv)] = \Pr[\textbf{Game } \text{INT-PTXT} \Rightarrow 1]
$$

\begin{figure}[H]
\begin{pchstack}[ center , boxed, space=0.5cm]
\procedure[linenumbering]{$\textbf{Game } \text{INT-PTXT}(\adv, \textsf{SE})$}{ 
K \sample \kgen(1^\lambda) \\
\mathcal{Q} \gets \emptyset  \\
\adv^\oracle[OEnc, OTry]() \\
\pcreturn \textsf{win}
}

\begin{pcvstack}[space = 0.3cm]
\procedure[linenumbering]{$\textbf{Oracle }\oracle[OEnc](m)$}{ 
c \gets \enc(K, m) \\
\mathcal{Q} \gets \mathcal{Q} \cup \{m\} \\
\pcreturn c
}
	
\procedure[linenumbering]{$\textbf{Oracle }\oracle[OTry](c^*)$}{ 
\textsf{win} \gets 0 \\
m^* \gets \dec(K, c^*) \\
\pcif m^* \not\in \mathcal{Q} \wedge m^* \neq \bot \pcthen \\
	\t \textsf{win} \gets 1
}
\end{pcvstack}
\end{pchstack}
\caption{INT-PTXT Game}
\label{fig:int-ptxt-game}
\end{figure}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{INT-CTXT $>$ INT-PTXT} If a symmetric encryption scheme $\SE$ is INT-CTXT secure, then it is also INT-PTXT secure. 

\begin{proof}
We prove by contraposition that if $\SE$ is not INT-CTXT, then it is not INT-PTXT. Let $\adv$ be a INT-CTXT adversary against $\SE$, we construct an adversary $\bdv$ against INT-PTXT of $\SE$ such that $\bdv$ runs $\adv$ and replys $\adv$'s queries to $\bdv$'s $\oracle[OEnc]$ and $\oracle[OTry]$. 

We have that $\bdv$ simulates the INT-CTXT game of $\adv$ since $\bdv$ makes the exact the same number of queries as $\adv$ and $\bdv$ returns the same $c^*$ as $\adv$. 

We have that $\bdv$ wins if $\adv$ wins. Let $c^*$ be the ciphertext query $\adv$ makes to $\oracle[OTry]$. Since $\adv$ wins, we have that $c^* \not\in \mathcal{Q}_c$, which implies $m^* \not\in \mathcal{Q}_m$ where $m^* = \dec(K, c^*)$. Thus $\bdv$ wins if $\adv$ wins. 

\end{proof}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Ciphertext Indistinguishability}
\subsubsection{IND-CPA Security}
A symmetric encryption scheme  $\SE$ is defined to be $(q,t,\varepsilon)$-\textit{indistinguishibility under chosen plaintext attack} ($\indcpa)$ secure, if for any adversaries $\adv$ running in time at most $t$ and making at most $q$ encryption queries, the advantage $\advantage{\indcpa}{\SE}[(\adv)] \leq \varepsilon$ where 

$$
\advantage{\indcpa}{\SE}[(\adv)] = 2 \cdot | \Pr[\textbf{Game } \indcpa(\adv, \SE) \Rightarrow \true ] - \frac{1}{2} | 
$$ 


\begin{figure}[H]
\begin{pchstack}[ center , boxed, space=0.5cm]
\procedure[linenumbering]{$\textbf{Game }\indcpa(\adv, \SE)$}{ 
b \sample \bin \\
K \sample \kgen(1^\lambda) \\ 
b' \sample \adv^{\oracle[LoR] }() \\
\pcreturn b'= b
 }

\procedure[linenumbering]{$\textbf{Oracle }\oracle[LoR](m_0, m_1)$}{ 
\pcif |m_0| \neq |m_1| \pcthen \\ 
	\t \pcreturn \bot \\
c \sample \enc_K(m_b) \\
 \pcreturn c
}
\end{pchstack}
\caption{IND-CPA Game}
\label{fig:indcpa-game}
\end{figure}

\bigskip 
\textit{Remarks:}
\begin{enumerate}
	\item $\indcpa$ security imples decryption security.
	\item $\indcpa$ security implies key recovery ($\textsc{TKR}$) security.
	\item $\indcpa$ security ensures that every bit of the plaintext is hidden. 
	\item One-time Pad is $\indcpa$ is 1-query $\indcpa$ secure. 
	\item Here oracle $\oracle[LoR]$ refers to "left or right". 
	\item A special form of $\indcpa$ security, which formalize the indistinguishability of a symmetric encryption scheme from random bits, named IND\$-CPA, is defined as in Figure~\ref{fig:indcpa$-game}. 
\end{enumerate}


\begin{figure}[H]
\begin{pchstack}[ center , boxed, space=0.5cm]
\procedure[linenumbering]{$\textbf{Game }\text{IND\$-CPA}(\adv, \SE)$}{ 
b \sample \bin \\
K \sample \kgen(1^\lambda) \\ 
b' \sample \adv^{\oracle[RoR] }() \\
\pcreturn b'= b
}
	
\procedure[linenumbering]{$\textbf{Oracle }\oracle[RoR](m)$}{ 
\pcif b = 0 \pcthen \\
	\t c \sample \enc(K, m) \\ 
\pcelse \\
	\t c \sample \mathcal{C} \\ 
\pcreturn c
}
\end{pchstack}
\caption{IND\$-CPA Game}
\label{fig:indcpa$-game}
\end{figure}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{IND-CCA Security}
A symmetric encryption scheme  $\SE$ is defined to be $(q_e, q_d, t,\varepsilon)$-\textit{indistinguishibility under chosen ciphertext attack} secure ($\indcca)$, if for any adversaries $\adv$ running in time at most $t$ and making at most $q_e$ encryption queries to oracle $\oracle[LoR]$ and at most $q_d$ decryption queries to oracle $\oracle[ODec]$, the advantage $\advantage{\indcpa}{\SE}[(\adv)] \leq \varepsilon$.

$$
\advantage{\indcca}{\SE}[(\adv)] = 2 \cdot | \Pr[\textbf{Game } \indcca(\adv, \SE) \Rightarrow \true ] - \frac{1}{2} | 
$$ 


\begin{figure}[H]
\begin{pchstack}[ center , boxed, space=0.5cm]
\procedure[linenumbering]{$\textbf{Game }\indcca(\adv, \SE)$}{ 
b \sample \bin \\
K \sample \kgen(1^\lambda) \\ 
\mathcal{Q} \gets \emptyset  \\
b' \sample \adv^{\oracle[LoR], \oracle[ODec] }() \\
\pcreturn b'= b
 }


\procedure[linenumbering]{$\textbf{Oracle }\oracle[LoR](m_0, m_1)$}{
	\pcif |m_0| \neq |m_1| \pcthen \\ 
	\t \pcreturn \bot \\  
	c \sample \enc_K(m_b) \\
	\mathcal{Q} \gets \mathcal{Q} \cup \{c\}  \\
	\pcreturn c
}
	   
\procedure[linenumbering]{$\textbf{Oracle }\oracle[ODec](c)$}{ 
\pcif c \in \mathcal{Q} \pcthen \\ 
	\t \pcreturn \bot \\ 
m \gets \dec(K, c) \\ 
\pcreturn m
}

\end{pchstack}
\caption{IND-CCA Game}
\label{fig:indcca-game}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Authenticated Encryption}
\subsubsection{AE Security}
A symmetric encryption scheme $\SE$ is said to be \textit{authenticated encryption} (AE) if it is $\indcpa$ secure and an adversary $\adv$ with access to an encryption oracle cannot forge any new ciphertexts i.e.,
$$
\text{AE} := \indcpa + \text{INT-CTXT}
$$




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Nonce-based AEAD}
A nonce-based AEAD scheme with key space $\mathcal{K}$, message space $\mathcal{M}$, ciphertext space $\mathcal{C}$, nonce space $\mathcal{N}$, and associated data space $\mathcal{AD}$, consists of a triple of algorithms $(\kgen, \enc, \dec)$ where:
$$
\begin{aligned}
&\kgen: \{\} \rightarrow \mathcal{K} \\
&\enc: \mathcal{K} \times \mathcal{N} \times \mathcal{AD} \times \mathcal{M} \rightarrow \mathcal{C} \\ 
&\dec: \mathcal{K} \times \mathcal{N} \times \mathcal{AD} \times \mathcal{C}\rightarrow \mathcal{M} \cup \{\bot\}
\end{aligned}
$$
such that: 
$$
\forall k \in \mathcal{K} \ \forall m \in \mathcal{M} \ \forall N \in \mathcal{N} \ \forall AD \in \mathcal{AD}, \dec(K, N, AD, \enc(K,N,AD,m)) = m
$$


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Case Study: Prove CTR mode is IND-CPA}
In this section, we prove that the following theorem:

\begin{theorem}
Let $\adv$ be an $\indcpa$ adversary against the (simplified) CTR mode $\SE$ based on a block cipher $E$, then we can construct a $\prp$ adversary $\bdv$ against $E$ such that 
$$
\advantage{\indcpa}{\SE_\textsc{ctr}}[(\adv)] \leq 2\cdot \advantage{\prp}{E}[(\bdv)] + \frac{q^2}{2^{n-1}}
$$
\end{theorem}

\begin{proof}
Consider the games $\mathrm{G}_0 - \mathrm{G}_3$ defined in Figure \ref{fig:indcpa-ctr-proof}. Let $W_i$ be the event that $b=b'$ in $\mathrm{G}_i$ respectively, we have that 
$$
\advantage{\indcpa}{\SE_\textsc{ctr}}[(\adv)] = \advantage{\mathrm{G_0}}{\SE_\textsc{ctr}}[(\adv)] = 2 \cdot \abs{\Pr[W_0] - \frac{1}{2}} 
$$
Note that we have 
$$
\begin{aligned}
\abs{\Pr[W_0] - \frac{1}{2}} &= \abs{(\Pr[W_0] - \Pr[W_1]) + (\Pr[W_1] - \Pr[W_2]) + (\Pr[W_2] - \Pr[W_3]) + (\Pr[W_3] - \frac{1}{2})} \\  
&\leq \abs{(\Pr[W_0] - \Pr[W_1])} + \abs{(\Pr[W_1] - \Pr[W_2])} + \abs{(\Pr[W_2] - \Pr[W_3])} + \abs{(\Pr[W_3] - \frac{1}{2})}
\end{aligned}
$$
Since in $\mathrm{G_3}$, we have that the encryption is done via a OTP, which has perfect secrecy, we have that 
$$
\advantage{\mathrm{G_3}}{\SE_\textsc{ctr}}[(\adv)] = 2 \cdot \abs{\Pr[W_3] - \frac{1}{2}} = 0
$$
Thus we have that 
$$
\abs{\Pr[W_0] - \frac{1}{2}} \leq \abs{(\Pr[W_0] - \Pr[W_1])} + \abs{(\Pr[W_1] - \Pr[W_2])} + \abs{(\Pr[W_2] - \Pr[W_3])}
$$

We first want to show that $\abs{\Pr[W_0] - \Pr[W_1]} \leq \advantage{\prp}{E}[(\bdv)]$ for some $\prp$ adversary $\bdv$ against the block cipher $E$. We define $\bdv$ as in Figure \ref{fig:indcpa-ctr-proof-bdv}. Observe that $\bdv$ makes the same number of queries as $\adv$ makes, $\bdv$ internally flips a coin and uses its own $\oracle[RoR]$ oracle to simulate the queries $\adv$ makes to the $\oracle[LoR]$ oracle. Also, the running time of $\bdv$ is essentially of $\adv$. Thus we have that $\bdv$ perfectly simuate the $\indcpa$ that $\adv$ plays. Let $d$ be the secret bit in the $\prp$ game that $\bdv$ plays, we have that 
$$
\Pr[W_0] = \Pr[b'=b \mid \mathrm{G_0}(\adv)] = \Pr[b=b' \mid d = 0] = \Pr[d' = 0 \mid d = 0]
$$
and 
$$
\Pr[W_1] = \Pr[b'=b \mid \mathrm{G_1}(\adv)] = \Pr[b=b' \mid d = 0] = \Pr[d' = 0 \mid d = 1]
$$
By Advantage Rewriting Lemma, we have that 
$$
\begin{aligned}
\advantage{\prp}{E}[(\bdv)] &= \abs{\Pr[d' = 0 | d = 0] - \Pr[d'=0 | d = 1]}  \\ 
&= \abs{\Pr[W_0] - \Pr[W_1]}
\end{aligned} 
$$

We then prove that $\abs{\Pr[W_1] - \Pr[W_2]} \leq \frac{q^2}{2^{n+1}}$ where $q$ denotes the number of queries. We construct an adversary $\bdv_1$ that distinguish between a random permutation and a random function as in Figure \ref{fig:indcpa-ctr-proof-bdv-1}. Note that $\bdv_1$ makes the same number of queries that $\adv$ does, $\bdv_1$ flips the coin internally and simulates the $\oracle[LoR]$ oracle queries made by $\adv$ with its own oracle $\oracle[RoR]$. Also, $\bdv_1$ runs in the essentially the same time as $\adv$. Thus $\bdv_1$ perfectly simulates the $\indcpa$ game that $\adv$ plays. Let $d$ be the secret bit in the $\prp-\prf$ game that $\bdv_1$ plays, we have that: 
$$
\Pr[W_1] = \Pr[b'=b \mid \mathrm{G_1}(\adv)] = \Pr[b=b' \mid d = 0] = \Pr[d' = 0 \mid d = 0]
$$
and 
$$
\Pr[W_2] = \Pr[b'=b \mid \mathrm{G_2}(\adv)] = \Pr[b=b' \mid d = 0] = \Pr[d' = 0 \mid d = 1]
$$
By Advantage Rewriting Lemma and PRP-PRF Switching Lemma, we have that: 
$$
\begin{aligned}
\advantage{\prp}{E}[(\bdv)] &= \abs{\Pr[d' = 0 | d = 0] - \Pr[d'=0 | d = 1]}  \\ 
&= \abs{\Pr[W_1] - \Pr[W_2]} \\ 
&\leq \frac{q^2}{2^{n+1}}
\end{aligned} 
$$

We finally want to show that $\Pr[W_2] - \Pr[W_3] \leq \frac{q^2}{2^{n+1}}$. We construct a IND-CPA challenger $\bdv_2$. Define $\bdv_2$ as in Figure \ref{fig:indcpa-ctr-proof-bdv-2}. Observe that $\mathrm{G}_2$ and $\mathrm{G}_3$ are identical unless the randomly chosen values for $ctr$ are not all distinct. Let $Z$ be such event. We have that $(W_2 \wedge \neg Z)$ happens if and only if $(W_3 \wedge \neg Z)$ occurs. Similarly, we have that $\Pr[Z] = \frac{q(q-2)}{2^{n+1}} \leq \frac{q^2}{2^{n+1}}$. Thus by Difference Lemma, we have that 
$$
\abs{\Pr[W_2] - \Pr[W_3]} \leq \Pr[Z] \leq \frac{q^2}{2^n+1}
$$

Finally, we have that:
$$
\begin{aligned}
\advantage{\indcpa}{\SE_\textsc{ctr}}[(\adv)] &=  2 \cdot \abs{\Pr[W_0] - \frac{1}{2}}  \\
&\leq 2 \cdot \abs{(\Pr[W_0] - \Pr[W_1])} + 2 \cdot \abs{(\Pr[W_1] - \Pr[W_2])} + 2 \cdot \abs{(\Pr[W_2] - \Pr[W_3])} \\ 
&\leq 2 \cdot \advantage{\prp}{E}[(\bdv)] + \frac{2q^2}{2^{n+1}} + \frac{2q^2}{2^{n+1}} \\
&= 2 \cdot \advantage{\prp}{E}[(\bdv)] + \frac{q^2}{2^{n-1}} 
\end{aligned} 
$$
\end{proof} 

\begin{figure}[H]
\begin{pchstack}[center, boxed, space=0.5cm]
\procedure[linenumbering]{$\textbf{Game } \mathrm{G_0} \ \fbox{$\mathrm{G_1}$} 
\gamechange{$\mathrm{G_2}$} \ \gamechange{\fbox{$\mathrm{G_3}$}} (\adv, \SE)$}{ 
	b \sample \bin \\
	K \sample \kgen(1^\lambda) \\ 
	\fbox{$\pi \sample \mathcal{P}(\bin^n)$} \\ 
	\gamechange{$\rho \sample \mathcal{F}(\bin^n)$} \\ 
	b' \sample \adv^{\oracle[LoR]_0}() \\
	\pcreturn b'= b
}
\procedure[linenumbering]{$\textbf{Oracle }\oracle[LoR](m_0, m_1)$}{ 
	ctr \sample \bin^n \\ 
	r \gets E_K(ctr) \\ 
	\fbox{$r \gets \pi(ctr)$} \\
	\gamechange{$r \gets \rho(ctr)$} \\ 
	\gamechange{\fbox{$r \sample \bin^n $}} \\ 
	c_0 \gets m_b \oplus r \\
	c \gets ctr || c_0 \\ 
	\pcreturn c
}
\end{pchstack}
\caption{Game for IND-CPA CTR proof }
\label{fig:indcpa-ctr-proof}
\end{figure}

\begin{figure}[H]
\begin{pchstack}[center, boxed, space=0.5cm]
\procedure[linenumbering]{$\textbf{Adversary } \bdv^\oracle[RoR]$}{ 
	b \sample \bin \\
	b' \sample \adv^{\oracle[LoR_\simulator]}() \\
	\pcif b = b' \pcthen \\ 
		\t \pcreturn 0 \\ 
	\pcelse \\
		\t \pcreturn 1 
}

\procedure[linenumbering]{$\textbf{Oracle }\oracle[RoR](m)$}{ 
	\pcif b = 0 \pcthen \\ 
		\t \pcreturn E_K(m) \\ 
	\pcelse \\	
		\t \pcreturn \pi(m)
}

\procedure[linenumbering]{$\textbf{Oracle }\oracle[LoR_\simulator](m_0, m_1)$}{ 
	ctr \sample \bin^n \\ 
	r \gets \oracle[RoR](ctr) \\ 
	c_0 \gets m_b \oplus r \\
	c \gets ctr || c_0 \\ 
	\pcreturn c
}
\end{pchstack}
\caption{Adversary $\bdv$ for IND-CPA CTR proof }
\label{fig:indcpa-ctr-proof-bdv}
\end{figure}


\begin{figure}[H]
	\begin{pchstack}[center, boxed, space=0.5cm]
	\procedure[linenumbering]{$\textbf{Adversary } \bdv_1^\oracle[RoR]$}{ 
		b \sample \bin \\
		b' \sample \adv^{\oracle[LoR_\simulator]}() \\
		\pcif b = b' \pcthen \\ 
			\t \pcreturn 0 \\ 
		\pcelse \\
			\t \pcreturn 1 
	}
	
	\procedure[linenumbering]{$\textbf{Oracle }\oracle[RoR](m)$}{ 
		\pcif b = 0 \pcthen \\ 
			\t \gamechange{$\pcreturn \pi(m)$} \\ 
		\pcelse \\	
			\t \gamechange{$\pcreturn \rho(m)$}
	}
	
	\procedure[linenumbering]{$\textbf{Oracle }\oracle[LoR_\simulator](m_0, m_1)$}{ 
		ctr \sample \bin^n \\ 
		r \gets \oracle[RoR](ctr) \\ 
		c_0 \gets m_b \oplus r \\
		c \gets ctr || c_0 \\ 
		\pcreturn c
	}
	\end{pchstack}
	\caption{Adversary $\bdv_1$ for IND-CPA CTR proof }
	\label{fig:indcpa-ctr-proof-bdv-1}
	\end{figure}


	\begin{figure}[H]
		\begin{pchstack}[center, boxed, space=0.5cm]
		\procedure[linenumbering]{$\textbf{Challenger } \bdv_2$}{ 
			b \sample \bin
		}
		
		\procedure[linenumbering]{$\textbf{Oracle }\oracle[RoR](m)$}{ 
			\pcif b = 0 \pcthen \\ 
				\t \gamechange{$\pcreturn \rho(m)$} \\ 
			\pcelse \\	
				\t \gamechange{$r \sample \bin^n$} \\ 
				\t \gamechange{$\pcreturn r$}
		}
		
		\procedure[linenumbering]{$\textbf{Oracle }\oracle[LoR_\simulator](m_0, m_1)$}{ 
			ctr \sample \bin^n \\ 
			r \gets \oracle[RoR](ctr) \\ 
			c_0 \gets m_b \oplus r \\
			c \gets ctr || c_0 \\ 
			\pcreturn c
		}
		\end{pchstack}
		\caption{Challenger $\bdv_2$ for IND-CPA CTR proof }
		\label{fig:indcpa-ctr-proof-bdv-2}
		\end{figure}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Case Study: CBC Padding Oracle Attack} 
The CBC mode of encryption is defined as:
\bigskip
\begin{pchstack}[ center , space=0.5cm]
\procedure[linenumbering]{$\textsf{CBC}[E].\mathcal{E}_K(M_1||\cdots ||M_\ell)$}{ 
	C_0 \sample \bin^n \\
	\pcfor i = 1,\cdots, \ell \pcdo \\
	\t C_i \gets E_K(M_i \oplus C_{i-1}) \\
	\pcreturn C_0 || C_1 || \cdots || C_\ell
}

\procedure[linenumbering]{$\textsf{CBC}[E].\mathcal{D}_K(C_0|| C_1 ||\cdots ||C_\ell)$}{ 
	\pcfor i = 1,\cdots, \ell \pcdo \\
	\t M_i \gets E^{-1}_K(C_i) \oplus C_{i-1} \\
	\pcreturn C_0 || C_1 || \cdots || C_\ell
}
\end{pchstack}

First is to recover the \textit{Last Byte}. Let $\textsf{pad}$ denote the minimum possible padding byte of a legitimate padding scheme, to recovery $M_\ell[n]$, follow the process 
	\begin{pchstack}[ center , space=0.5cm]
		\procedure[linenumbering]{$\textsf{Padding-Oracle-Last-Byte}$}{ 
		\pcfor i = \texttt{0x00}, \cdots, \texttt{0xff} \pcdo \\
		\t C'_{\ell - 1} \gets C_{\ell-1} \oplus (\texttt{0x00}||...||i) \\
		\t C' \gets C_0 || ... || C_{\ell-1} || C_\ell \\  
		\t \textsf{good-pad} \gets \oracle[Padding](C') \\
		\t \pcif \textsf{good-pad} = \true \pcthen \\
		\t\t v \gets (\texttt{0x00}||...||i) \oplus (\texttt{0x00}||...||\textsf{pad}) \\
		\t\t \pcreturn v[n]
		}
	\end{pchstack}
	Denote $\Delta_{\ell,n}$ as the value of $i$ such that $\textsf{good-pad}$ is set to  $\true$, according to the decryption scheme, we have that 
	$$
	\begin{aligned}
		C_{\ell-1}[n] \oplus \Delta_{\ell,n} \oplus E^{-1}(C_\ell)[n] &= \textsf{pad} \\
		C_{\ell-1}[n] \oplus E^{-1}(C_\ell)[n] &= \textsf{pad} \oplus \Delta_{\ell,n} \\
		M_\ell[n] &= \textsf{pad} \oplus \Delta_{\ell,n} 
	\end{aligned}
	$$
Then we can recover the full block following the similar strategy. Let $\textsf{pad}' = \textsf{pad} + 1$, compute $\Delta_{\ell,n}' = \Delta_{\ell,n} \oplus \textsf{pad}'$ and $C_\ell' = C_\ell \oplus (\texttt{0x00} || \cdots || \Delta_{\ell,n}')$ and run the above process again. Note this time, we have  
$$
\begin{aligned}
	(C_{\ell-1}[n-1]||C_{\ell-1}[n]) \oplus (\Delta_{\ell,n-1} || \Delta_{\ell,n}') \oplus (E^{-1}(C_\ell)[n-1]||E^{-1}(C_\ell)[n]) &= \textsf{pad}' || \textsf{pad}'  \\
	(C_{\ell-1}[n-1]||C_{\ell-1}[n]) \oplus (E^{-1}(C_\ell)[n-1] ||E^{-1})(C_\ell)[n]) &= \textsf{pad}' || \textsf{pad}' \oplus \Delta_{\ell,n-1} || \Delta_{\ell,n}' \\
	M_\ell[n-1] &= \textsf{pad} \oplus \Delta_{\ell,n-1} 
\end{aligned}
$$






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Hash Function
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Hash Function}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Hash Function} A \textit{(cryptographic) hash function} $H$ with message space $\mathcal{M}$ and digest space $\mathcal{T}$ is an efficiently computable function $H: \mathcal{M} \rightarrow \mathcal{T}$ mapping an arbitrary length input string to a fixed-length message digest. A \textit{keyed hash function} $H$ with key space $\mathcal{K}$, message space $\mathcal{M}$ and digest space $\mathcal{T}$ is deterministic algorithm that takes two inputs, a key $K \in \mathcal{K}$ and a message $m \in \mathcal{M}$ and output $t := H(K,m) \in \mathcal{T}$.  



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Security Goals for Hash Function}
\subsubsection{Informal Definition}
\begin{itemize}
	\item \textit{Primary Security Goals}
	\begin{enumerate}
		\item Pre-image Resistance (one-wayness): Given $h$, it is infeasible to find $m \in \bin^*$ such that $H(m) = h$. (See \textit{Digital Signature Lecture Note} for adversary-based definition). 
		\item Second Pre-image Resistance: given $m_1$, it is infeasible to find $m_2 \neq m_1$ such that $H(m_1) = H(m_2)$. 
		\item Collision Resistance: it is infeasible to find $_1 \neq m_2$ such that $H(m_1) \neq H(m_2)$. 
	\end{enumerate}
	\item \textit{Secondary Security Goals}
	\begin{enumerate}
		\item Near-collision Resistance: it is infeasible to find $m_1 \neq m_2$ such that $H(m_1) \approx H(m_2)$. 
		\item Partial Pre-image Resistance 1: given $H(m)$, it is infeasible to recover any partial information about $m$. 
		\item Partial Pre-image Resistance 2: given a target string $t$ of bit-length $\ell$, it is infeasible to find $m \in \bin^*$ such that $H(m) = t || z$ in time significantly faster than $2^\ell$ hash evluations. 
	\end{enumerate}
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Collision Resistance} Let $H: \mathcal{D} \rightarrow \mathcal{R}$ be a hash function. An algorithm $\adv$ is said to be $(t,\varepsilon)$ \textit{collision resistance} (CR) adversary against $H$ if $\adv$ runs in time $t$ with advantage

$$
\advantage{CR}{H}[(\adv)] = \Pr[\textbf{Game } \text{CR} \Rightarrow 1] = \varepsilon
$$ 

\begin{figure}[H]
\begin{pchstack}[ center , boxed, space=0.5cm]
\procedure[linenumbering]{$\textbf{Game } \text{CR}(\adv, H) $}{ 
(m, m') \sample \adv() \\
\pcif m \neq m' \wedge H(m) = H(m') \pcthen \\
	\t \pcreturn 1 \\
\pcelse \\
	\t \pcreturn 0
}
\end{pchstack}
\caption{Collision Resistance (CR) Game}
\label{fig:cr-game}
\end{figure}

\bigskip
\textit{Remarks:}
\begin{enumerate}
	\item Collision must exist because $|\mathcal{D}| \gg |\mathcal{R}|$.
	\item Fix a hash function $H$, there must be an efficient algorithm $\adv$ that outputs collisions. 
	\item Thus we cannot have a security definition for collision resistance that quantifies over all efficient algorithms $\adv$. 
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Second Pre-image Resistance}
Let $H: \mathcal{D} \rightarrow \mathcal{R}$ be a hash function. An algorithm $\adv$ is said to be $(t,\varepsilon)$ \textit{second pre-image resistance} (2PRE) adversary against $H$ if $\adv$ runs in time $t$ with advantage  

$$
\advantage{2Pre}{H}[(\adv)] = \Pr[\textbf{Game } \text{2Pre} \Rightarrow 1] = \varepsilon
$$ 

\begin{figure}[H]
\begin{pchstack}[ center , boxed,  space=0.5cm]
\procedure[linenumbering]{$\textbf{Game } \text{2Pre}(\adv, H) $}{ 
m \sample \mathcal{D} \\ 
h \gets H(m) \\
m' \sample \adv(m, h) \\
\pcif m \neq m' \wedge H(m') = h \pcthen \\
	\t \pcreturn 1 \\
\pcelse \\
	\t \pcreturn 0
}
\end{pchstack}
\caption{Second Preimage Resistance (2Pre) Game}
\label{fig:2pre-game}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Pre-image Resistance}
Let $H: \mathcal{D} \rightarrow \mathcal{R}$ be a hash function. An algorithm $\adv$ is said to be $(t,\varepsilon)$ \textit{pre-image resistance} ((r)PRE) adversary against $H$ if $\adv$ runs in time $t$ with advantage  

$$
\advantage{(r)Pre}{H}[(\adv)] = \Pr[\textbf{Game } \text{(r)Pre} \Rightarrow 1] = \varepsilon
$$ 

\begin{figure}[H]
\begin{pchstack}[ center , boxed, space=0.5cm]
\procedure[linenumbering]{$\textbf{Game } \text{rPre}(\adv, H) $}{ 
h \sample \mathcal{R} \\
m \sample \adv(h) \\
\pcif H(m) = h \pcthen \\
\t \pcreturn 1 \\
\pcelse \\
\t \pcreturn 0 
}


\procedure[linenumbering]{$\textbf{Game } \text{Pre}(\adv, H) $}{ 
m \sample \mathcal{D} \\ 
h \gets H(m) \\
m' \sample \adv(m, h) \\
\pcif H(m') = h \pcthen \\
	\t \pcreturn 1 \\
\pcelse \\
	\t \pcreturn 0
}
\end{pchstack}
\caption{rPre and Pre Game}
\label{fig:rpre-game}
\end{figure}


\textit{Remarks:}
\begin{enumerate}
\item The notation PRE is also denoted as \textit{one-wayness}. We then say that $H$ is a \textit{one-way function} (OWF). 
\end{enumerate}







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{CR $>$ 2Pre} Any hash function that is collision resistant is also second pre-image-resistant
\begin{proof}
Assume by contraposition a hash function $H$ is not second pre-image-resistance, we want to prove that $H$ is not collision resistant. Let $\adv$ be an adversary against second pre-image resistance of $H$, we want to construct an $\bdv$ against collision resistance of $H$. Define $\bdv$ as follows: 

\begin{pchstack}[ center , space=0.5cm]
\procedure[linenumbering]{$\textbf{Adversary }\bdv$}{ 
m \sample \mathcal{D} \\
h \gets H(m) \\ 
m' \sample \adv(m, h) \\
\pcreturn (m,m')
}
\end{pchstack}
We have that $\advantage{CR}{H}[(\adv')] = \advantage{2Pre}{H}[(\adv)]$. Thus if $H$ is collision resistant, $H$ is second pre-image resistant. 

\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Merkle-Damgård Construction} 
\subsection{Construct from compression function}
Let $k$ be block length, $n$ be output length, $\textsf{IV} \in \bin^n$ be constant. Let $h: \bin^k \times \bin^n \rightarrow \bin^n$. The Merkle-Damgård Construction is as defined in Figure \ref{fig:md-construction}. 

\begin{figure}[H]
\begin{pchstack}[center , boxed, space=0.5cm]
\procedure[linenumbering]{$\text{Merkle-Damgård}(m)$}{ 
m' \gets \pad(m) \\ 
m_1' || \cdots || m_\ell' \gets m' \\ 
t_0 \gets \textsf{IV} \\ 
\pcfor i = 1, \cdots, \ell \pcdo \\ 
	\t t_i \gets h(m_i', t_{i-1}) \\
\pcreturn t_\ell
}
\end{pchstack}
\caption{Merkle-Damgård Construction}
\label{fig:md-construction}
\end{figure}

\textit{Remarks}: 
\begin{enumerate}
\item Classical construction from block cipher to compression including Davis-Meyer Construction by: 
$$
h(m_i, t_{i-1}) = E(m_i, t_{i-1}) \oplus t_{i-1}
$$
Note that \textit{Davis-Meyer Construction} gives a collision resistant compression function if $E$ is an $\textit{ideal cipher}$. 
\end{enumerate}


\subsubsection{Security}
Suppose $\pad(m)$ transforms $m$ into $m' = m || 10^t || [|m|]_L$ where $0 \leq t < k$is minimal such that $k$ divides $|m'|$ and $[\cdot]_L$ denotes $L$-bit representation of a number where $L \leq K$. If the compression function $h$ is collision-resistant, then so is $H$. 
\begin{proof}
Let $\adv$ be an adversary against CR of hash function $H$ built from compression function $h$ using the Merkle-Damgård Construction. We construct an adversary $\bdv$ from $\adv$ that breaks CR security of $h$. 

Suppose that $\adv$ outputs a colliding pair $X \neq Y$ with non-negligible advantage. Since we know $X \neq Y$, we have that $\pad(X)$ and  $\pad(Y)$ do not need to have the same number of blocks. Let $x_i, y_j$ be their blocks after being padded. We write $\pad(X) = x_1,x_2, \cdots, x_u$ and $\pad(Y) = y_1, y_2, \cdots, y_v$. Let $s_i$ be the chaining values for $X$ and $t_1$ be the chaining values for $Y$. Thus if we look at the last blocks in the two chains, we have that 
$$
h(s_{u-1}, x_u) = H(X) = H(Y) = h(t_{v-1}, y_v) 
$$
Now we consider two cases. In the first case, we have that $(s_{u-1}, x_u) \neq (t_{v-1}, y_v)$. In this case, the pair $(s_{u-1}, x_u)$ and $(t_{v-1}, y_v)$ if a collision for $h$. Then the adversary $\bdv$ outputs the collision and terminates. 

In the second case, we have that we have that $(s_{u-1}, x_u) = (t_{v-1}, y_v)$. Since $x_u, y_v$ both uniquely encode the length of $X$ and $Y$ respectively, we can deduce from $x_u = y_v$ that $u=v$ and the message are of identical length. Now since $s_{u-1} = t_{u-1}$, we have that 
$$
h(s_{u-2}, x_{u-1}) = s_{u-1} = t_{u-1} = h(t_{v-2}, y_{v-1}) 
$$
We then follow the process and the process must end with a collision in $h$, otherwise we would eventually find hat all blocks of $\pad(X)$ equal those of $\pad(Y)$, contradicting the fact that $X \neq Y$. Thus we have that $\bdv$ must outputs a collision and $h$. 

Therefore, by contraposition, if a compression $h$ is collision resistant, the then hash function constructed from $h$ with Merkle-Damgård Construction is collision resistant. 
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Universal Hashing Function (UHF)}
\subsubsection{UHF Security} A keyed hash funcion $H$ is an $\varepsilon$-bounded \textit{universal hash function} ($\varepsilon$-UHF) if for any adversary $\adv$, the advantage $\advantage{UHF}{H}[(\adv)] \leq \varepsilon$ where 
$$
\advantage{UHF}{H}[(\adv)] = \Pr[\textbf{Game } \text{UHF} \Rightarrow 1]
$$

\begin{figure}[H]
\begin{pchstack}[center , boxed, space=0.5cm]
\procedure[linenumbering]{$\textbf{Game } \text{UHF}(\adv, H) $}{ 
K \sample \mathcal{K} \\ 
(m_0, m_1) \sample \adv() \\ 
\pcif H(K, m_0) = H(K, m_1) \\ 
	\t\t  \wedge m_0 \neq m_1 \pcthen \\ 
	\t \pcreturn 1 \\
\pcelse \\
	\t \pcreturn 0
}
\end{pchstack}
\caption{UHF Game}
\label{fig:uhf-game}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{UHF from Polynomial}
Let $\FF$ be a finite field, set $\mathcal{K} = \mathcal{T} = \FF$, $\mathcal{M} = (\FF)^{\leq L}$. Define a hash function $H_\text{poly}$ as:
$$
H_\text{poly}(K, (a_1, \cdots, a_v)) = K^v + a_1K^{v-1} + a_2K^{v-2} + \cdots + a_{v-1}K + a_v \in \FF
$$
We have that $H_\text{poly}$ is an $\varepsilon$-UHF for $\varepsilon = \frac{L}{|\FF|}$ 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Difference Unpredictable Hashing Function (DUHF)}
\subsubsection{DUHF Security} A keyed hash function $H$ with digest space $\mathcal{T}$ equipped with a group operation "+", is an $\varepsilon$-bounded \textit{difference unpredictable hashing function} if for any adversary $\adv$, the advantage $\advantage{DUHF}{H}[(\adv)] \leq \varepsilon$ where 
$$
\advantage{DUHF}{H}[(\adv)] = \Pr[\textbf{Game } \text{DUHF} \Rightarrow 1]
$$

\begin{figure}[H]
\begin{pchstack}[center , boxed, space=0.5cm]
\procedure[linenumbering]{$\textbf{Game } \text{UHF}(\adv, H) $}{ 
K \sample \mathcal{K} \\ 
(m_0, m_1, \delta) \sample \adv() \\ 
\pcif H(K, m_0) - H(K, m_1) = \delta \\ 
	\t\t \wedge m_0 \neq m_1 \pcthen \\ 
	\t \pcreturn 1 \\
\pcelse \\
	\t \pcreturn 0
}
\end{pchstack}
\caption{DUHF Game}
\label{fig:duhf-game}
\end{figure}
	

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{DUHF from Polynomial}
Let $\FF$ be a finite field, set $\mathcal{K} = \mathcal{T} = \FF$, $\mathcal{M} = (\FF)^{\leq L}$. Define a hash function $H_\text{poly}$ as:
$$
\begin{aligned}
H_\text{Xpoly}(K, (a_1, \cdots, a_v)) &= K^{v+1} + a_1K^{v} + a_2K^{v-1} + \cdots + a_{v-1}K^2 + a_vK \in \FF \\
&= K \cdot H_\text{poly}(K, (a_1, \cdots, a_v))
\end{aligned}
$$
We have that $H_\text{xpoly}$ is an $\varepsilon$-UHF for $\varepsilon = \frac{L+1}{|\FF|}$ 




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Message Authentication Code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Message Authentication Code}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Message Authentication Code (MAC)} A MAC scheme with key space $\mathcal{K}$, message space $\mathcal{M}$ and tag space $\mathcal{T}$ consists of a triple of efficient algorithms $(\kgen, \Tag, \verify)$ where 
$$
\begin{aligned}
&\kgen: \{\} \rightarrow \mathcal{K} \\
&\Tag: \mathcal{K} \times \mathcal{M} \rightarrow \mathcal{T} \\ 
&\verify: \mathcal{K} \times \mathcal{M}\times \mathcal{T} \rightarrow \bin  
\end{aligned}
$$
such that 
$$
\forall K \ \forall m, \verify(K,m,\Tag(K,m) ) = 1
$$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{MAC Unforgeability}
\subsubsection{EUF-CMA (WUF-CMA) Security}
A MAC scheme is $(q_t, q_v, t, \varepsilon)$-\textit{existential unforgeability under chosen message attack} ($\eufcma$) secure, if for any adversaries making $q_t$ queries to tagging oracle $\oracle[OTag]$, $q_v$ queries to verification $\oracle[OVfy]$, and running in time at most $t$, the advantage $\advantage{\eufcma}{\mac}[(\adv)] \leq \varepsilon$ where 

$$
\advantage{\eufcma}{\mac}[(\adv)] = \Pr[\textbf{Game } \eufcma \Rightarrow 1] 
$$

\begin{figure}[H]
\begin{pchstack}[ center , boxed, space=0.5cm]
	\procedure[linenumbering]{$\textbf{Game }\eufcma(\adv, \mac)$}{ 
		K \sample \kgen(1^\lambda) \\
		\mathcal{Q} \gets \emptyset \\ 
		(m^*, \tau^*) \sample \adv^{\oracle[OTag], \oracle{\verify}}() \\ 
	 	\pcif m^* \in \mathcal{Q} \pcthen \\
		\t \pcreturn 0 \\
		\pcelse \\
		\t b \gets \verify_K(m, \tau) \\
		\t \pcreturn b 
	}

	\begin{pcvstack}[space=0.3cm]
	\procedure[linenumbering]{$\textbf{Oracle }\oracle[OTag](m)$}{ 
		\tau \gets \Tag_K(m) \\
		\mathcal{Q} \gets \mathcal{Q} \cup \{m\} \\
		\pcreturn \tau 
	}

	\procedure[linenumbering]{$\textbf{Oracle }\oracle[OVfy](m, \tau)$}{ 
		b \gets \verify_K(m, \tau) \\
		%\mathcal{Q} \gets \mathcal{Q} \cup \{m\} \\
		\pcreturn b
	}
	\end{pcvstack}
\end{pchstack}
\caption{EUF-CMA Game for $\mac$}
\label{fig:eufcma-game-mac}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{SUF-CMA Security}
A MAC scheme is $(q_t, q_v, t, \varepsilon)$-\textit{strong existential unforgeability under chosen message attack} ($\seufcma$) secure, if for any adversaries making $q_t$ queries to tagging oracle $\oracle[OTag]$, $q_v$ queries to verification oracle $\oracle[OVfy]$, and running in time at most $t$, the advantage $\advantage{\seufcma}{\mac}[(\adv)] \leq \varepsilon$ where

$$
\advantage{\seufcma}{\mac}[(\adv)] = \Pr[\textbf{Game } \seufcma \Rightarrow 1] 
$$

\begin{figure}[H]
\begin{pchstack}[ center , boxed,  space=0.5cm]
	\procedure[linenumbering]{$\textbf{Game }\seufcma(\adv, \mac)$}{ 
		K \sample \kgen(1^\lambda) \\
		\mathcal{Q} \gets \emptyset \\ 
		(m^*, \tau^*) \sample \adv^{\oracle[OTag], \oracle{\verify}}() \\ 
	 	\pcif (m^*, \tau^*) \in \mathcal{Q} \pcthen \\
		\t \pcreturn 0 \\
		\pcelse \\
		\t b \gets \verify_K(m^*, \tau^*) \\
		\t \pcreturn b 
	}

	\begin{pcvstack}[space=0.3cm]
	\procedure[linenumbering]{$\textbf{Oracle }\oracle[OTag](m)$}{ 
		\tau \gets \Tag_K(m) \\
		\mathcal{Q} \gets \mathcal{Q} \cup \{(m,\tau)\} \\
		\pcreturn \tau 
	}

	\procedure[linenumbering]{$\textbf{Oracle }\oracle[OVfy](m, \tau)$}{ 
		b \gets \verify_K(m, \tau) \\
		%\mathcal{Q} \gets \mathcal{Q} \cup \{(m,\tau)\} \\
		\pcreturn b
	}
	\end{pcvstack}
\end{pchstack}
\caption{SUF-CMA game for $\mac$}
\label{fig:sufcma-game-mac}
\end{figure}


\textit{Remarks}: 
\begin{enumerate}
\item $\eufcma$ and $\seufcma$ security are equivalent if $\Tag$ is deterministic and $\verify$ is built using $\Tag$. 
\item For any $m$ and $K$, there is precisely one value $\tau$ for which $\verify(K,m, \tau) = 1$, so a $\seufcma$ adversary does not have more advantage than a $\eufcma$ adversary.  
\end{enumerate}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{No-verify SUF-CMA} Let $\mac = (\kgen, \Tag, \verify)$ be a $\mac$ scheme. For any $(q_t, q_v, t, \varepsilon)$-$\seufcma$ adversary $\adv$ against $\mac$, there is a $(q_t, t', \varepsilon/q_v)$-no-verify-$\seufcma$ advesary $\bdv$ against $\mac$ with $t' \approx t$.  

\begin{figure}[H]
	\begin{pchstack}[ center , boxed,  space=0.5cm]
		\procedure[linenumbering]{$\textbf{Game }\seufcma(\adv, \mac)$}{ 
			K \sample \kgen(1^\lambda) \\
			\mathcal{Q} \gets \emptyset \\ 
			(m^*, \tau^*) \sample \adv^{\oracle[OTag]}() \\ 
			 \pcif (m^*, \tau^*) \in \mathcal{Q} \pcthen \\
			\t \pcreturn 0 \\
			\pcelse \\
			\t b \gets \verify_K(m, \tau) \\
			\t \pcreturn b 
		}
	
		\begin{pcvstack}[space=0.3cm]
		\procedure[linenumbering]{$\textbf{Oracle }\oracle[OTag](m)$}{ 
			\tau \gets \Tag_K(m) \\
			\mathcal{Q} \gets \mathcal{Q} \cup \{(m^*,\tau^*)\} \\
			\pcreturn \tau 
		}
	\end{pcvstack}
\end{pchstack}
\caption{No Verify Oracle SUF-CMA game for $\mac$}
\label{fig:no-verify-sufcma-game-mac}
\end{figure}

\textit{Remarks:}
\begin{enumerate}
\item This theorem does not hold for $\eufcma$ as there are (artifical) MAC schemes which are $\eufcma$ secure if $q_t = q$ but there exists an efficient $\eufcma$ adversary with advantage 1 if $q_t > 1$
\item The theorem holds if $\Tag$ is deterministic and $\verify$ is built using $\Tag$.  
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{MACs from PRFs} 
\subsubsection{MACs-from-PRFs Construction}
Let $F: \mathcal{K} \times \mathcal{M} 
\rightarrow \mathcal{T}$ be a pseudorandom function, we build a $\mac$ scheme $\mac(F)$ from $F$ with key space $\mathcal{K}$, message space $\mathcal{M}$, and tag space $\mathcal{T}$ as in Figure \ref{fig:mac-from-prf-construction}. 


\begin{figure}[H]
\begin{pchstack}[ center , boxed,  space=0.5cm]
\begin{pcvstack}[space=0.3cm]

\procedure[linenumbering]{$\kgen$}{ 
K \sample \bin^k \\
\pcreturn K 
}

\procedure[linenumbering]{$\Tag(K, m)$}{ 
\tau \gets F(K,m) \\ 
\pcreturn \tau 
}
\end{pcvstack}

\procedure[linenumbering]{$\verify(K, m, \tau)$}{ 
\tau' \gets F(K,m) \\ 
\pcif \tau = \tau' \pcthen \\ 
	\t \pcreturn 1 \\ 
\pcelse \\ 
	\t \pcreturn 0
}

\end{pchstack}
\caption{MAC from PRF construction}
\label{fig:mac-from-prf-construction}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{MACs-from-PRFs Security}
Let $F:\mathcal{K} \times \mathcal{M} \rightarrow \mathcal{T}$ be a function. For any $(q_t, t, \varepsilon)$-$\seufcma$ adversary $\adv$ against $\mac(F)$, there exists an adversary $\bdv$ against PRF security of $F$ that runs in time $t' \approx t$, making $q_t + 1$ queries, and has advantage at least $\varepsilon - \frac{1}{|\mathcal{T}|}$. 

\begin{proof}
Since we have that $\Tag$ is deterministic, it suffices to show that if there is an adversary $\adv$ against no-verify $\eufcma$ security of $\mac(F)$, then there is an adversary $\bdv$ against PRF security of $F$ with advantage at least $\varepsilon-\frac{1}{|\mathcal{T}|}$. Consider the games $\mathrm{G}_0$ and $\mathrm{G}_1$ in Figure \ref{fig:sec-mac-from-prf}. We have that $\mathrm{G}_0 = \mathrm{G}^\eufcma_F$ and $\mathrm{G}_1 = \mathrm{G}^\eufcma_f$.
We define two events $W_0$ and $W_1$ where:
\begin{itemize}
	\item $W_0$: $\adv$ plays $\mathrm{G}_0$ and outputs $(m^*, \tau^*)$ such that $\tau^* = F(K, m^*)$ and $m^* \not \in \mathcal{Q}$. 
	\item $W_1$: $\adv$ plays $\mathrm{G}_1$ and outputs $(m^*, \tau^*)$ such that $\tau^* = f(m^*)$ and $m^* \not\in \mathcal{Q}$. 
\end{itemize}
We claim that 
$$
\begin{aligned}
\advantage{\eufcma}{F}[(\adv)] = \Pr[W_0] &= \abs{\Pr[W_0] - \Pr[W_1] + \Pr[W_1] } \\
&\leq \abs{\Pr[W_0] - \Pr[W_1]} + \Pr[W_1] 
\end{aligned}
$$
We construct the adversary $\bdv$ as in Figure \ref{fig:sec-mac-from-prf}. Observe that $\bdv$ queries its $\oracle[RoR]$ oracle to tag $m$ queried by $\adv$, with either the pseudorandom function $F$ or the random function $\rho$, which simulates the behavior of $\mathrm{G}_1$ or $\mathrm{G}_2$. By the Advantage Rewriting Lemma, we have that 
$$
\begin{aligned}
\advantage{PRF}{F}[(\bdv)] &= \abs{\Pr[b' = 0 \mid b = 0] - \Pr[b'=0 \mid b=1]} \\
&= \abs{\Pr[\tau^* = F(K, m^*) \mid \mathrm{G}_0(\adv)] -  \Pr[\tau^* = f(m^*) \mid \mathrm{G}_1(\adv)]} \\
&= \abs{\Pr[W_0] - \Pr[W_1]}
\end{aligned}
$$
We next bound $\Pr[W_1]$. Consider that $\adv$ has seen the output of $f$ with input $m_1, m_1, \cdots$ and $\adv$ is required to guess the  value of $f$ with some new value $m^*$ as input. We have that $f$ is a truly random function, the value of $f$ at $m^*$ is uniformly random and independent from its value on all other inputs. Thus we have that $\Pr[W_1] = \frac{1}{|\mathcal{T}|}$. 
Therefore, we have that 
$$
\advantage{\eufcma}{F}[(\adv)] \leq \advantage{PRF}{F}[(\bdv)] + \frac{1}{|\mathcal{T}|}
$$

\end{proof}

\begin{figure}[H]
\begin{pchstack}[ center , boxed, space=0.5cm]
\procedure[linenumbering]{$\textbf{Game } \mathrm{G}_0 \ \gamechange{$\mathrm{G_1}$} $}{ 
 K \sample \kgen(1^\lambda) \\
\mathcal{Q} \gets \emptyset \\ 
(m^*, \tau^*) \sample \adv^{\oracle[OTag]}() \\ 
\pcif m^* \in \mathcal{Q} \pcthen \\ 
	\t \pcreturn 0 \\ 
\pcelse \\ 
	\t \tau' \gets F(K, m^*) \\ 
	\t \gamechange{$\tau' \gets f(m^*)$} \\ 
	\pcreturn \tau^* = \tau' 
}

\begin{pcvstack}[space=0.3cm]
\procedure[linenumbering]{$\textbf{Oracle } \oracle[OTag](m) $}{ 
\tau \gets F(K, m) \\
\gamechange{$\tau \gets f(m)$} \\ 
\mathcal{Q} \gets \mathcal{Q} \cup \{m\} \\
\pcreturn \tau 
}

\procedure[linenumbering]{$\textbf{Oracle } \oracle[OTag]_\simulator(m)$}{
\tau \gets \oracle[RoR](m) \\ 
\pcreturn \tau 
}
\end{pcvstack}

\procedure[linenumbering]{$\textbf{Adversary } \bdv^\oracle[RoR]$}{ 
	(m^*, \tau^*) \sample \adv^{\oracle[OTag]_\simulator}()\\ 
	\tau' \gets \oracle[RoR](m^*) \\ 
	\pcif \tau^* = \tau' \pcthen \\
	\t \pcreturn 0 \\ 
	\pcelse \\ 
	\t \pcreturn 1 
}

\end{pchstack}
\caption{Security Proof of MAC construction from PRF}
\label{fig:sec-mac-from-prf}
\end{figure}

\bigskip
\textit{Remark:}
\begin{enumerate}[(1)]
	\item This statements implies if $F$ is a $\prf$, then $\mac(F)$ is $\seufcma$. 
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Domain Extension Theorem} 
Let $\mac = (\kgen, \Tag, \verify)$ be a MAC scheme for message input space $\mathcal{M}$ with tag-length $t$ and key length $k$. Let $H: \mathcal{M}' \rightarrow \mathcal{M}$ be a hash function. Define a new MAC scheme $\textsc{HtMAC} = (\kgen, \Tag', \verify')$ for message input space $\mathcal{M}'$ by 
\begin{itemize}
\item $\Tag'(K, m) = \Tag(K, H(m))$
\item $\verify'(K, m, \tau) = \verify(K, H(m))$
\end{itemize}
For any SUF-CMA adversary $\adv$ against $\textsc{HtMAC}$, we can construct an SUF-CMA adversary $\bdv$ against $\mac$, or a collision resistance adversary $\cdv$ against of $H$ such that 

$$
\advantage{SUF-CMA}{\textsc{HtMAC}}[(\adv)] \leq \advantage{SUF-CMA}{\mac}[(\bdv)] + \advantage{CR}{H}[(\cdv)] 
$$


\begin{proof}
Let $W_0$ denote the event that $\adv$ wins SUF-CMA game. Let $W_1$ denote the event that $H(m) = H(m^*)$ where $m \neq m^*$. We claim that 
$$
\begin{aligned}
\advantage{SUF-CMA}{\textsc{HtMAC}}[(\adv)] &= \Pr[W_0] \\ 
&= \Pr[W_0 \wedge \neg W_1] + \Pr[W_1 \wedge W_1] \\ 
&\leq \Pr[W_0 \wedge \neg W_1] + \Pr[W_1] 
\end{aligned}
$$

We first construct the adversary $\bdv$ as in Figure \ref{fig:domain-extension-theorem}. Observe that in the simulated oracle, $\bdv$ computes  the hash of the message queried by $\adv$, and queries its oracle $\oracle[OTag]$ to get the tag, which simulates the SUF-CMA game $\adv$ plays. Note that if $\adv$ wins the SUF-CMA game, $(m^*, \tau^*)$ output by $\adv$ has never been queried before. Since in this case, we assume that collision does not happen, thus we have that the hash of $m^*$ has never been queried. Thus if $\adv$ wins, we have $\bdv$ wins, which implies 

$$
\advantage{SUF-CMA}{\textsc{HtMAC}}[(\adv)] = \advantage{SUF-CMA}{\mac}[(\bdv)] 
$$

We now construct the adversary $C$ as in Figure \ref{fig:domain-extension-theorem}. Similarly, $\cdv$ simulates the SUF-CMA game that $\adv$ plays. Also, since we assume that collision happens in this case, there must exist some $m' \in \mathcal{Q}$ such that $H(m') = H(m)$ and $m \neq m'$. Thus $\Pr[W_1] \leq \advantage{CR}{H}[(\cdv)]$. 

Finally, we have that 

$$
\begin{aligned}
\advantage{SUF-CMA}{\textsc{HtMAC}}[(\adv)] 
&\leq \Pr[W_0 \wedge \neg W_1] + \Pr[W_1] \\
&=  \advantage{SUF-CMA}{\mac}[(\bdv)]  + \advantage{CR}{H}[(\cdv)]
\end{aligned}
$$

\end{proof}


\begin{figure}[H]
	\begin{pcvstack}[ center , boxed, space=0.5cm]
	\begin{pchstack}[space=0.3cm]
	\procedure[linenumbering]{$\textbf{Adversary } \bdv^{\oracle[OTag]} $}{ 
	 (m^*, \tau^*) \sample \adv^{\oracle[OTag]_\simulator}() \\ 
	 h^* \gets H(m^*) \\
	 \pcreturn (h^*, \tau^*)
	}
	
	\procedure[linenumbering]{$\textbf{Oracle } \oracle[OTag]_\simulator(m)$}{
	h \gets H(m) \\ 
	\tau \gets \oracle[OTag](h) \\ 
	\pcreturn \tau 
	}
	\end{pchstack}

	\begin{pchstack}[space=0.3cm]
		\procedure[linenumbering]{$\textbf{Adversary } \cdv $}{ 
			(X, Y) \gets (\bot, \bot) \\ 
			\mathcal{Q} \gets \emptyset \\
			K \sample \kgen \\ 
			\adv^{\oracle[OTag]'_\simulator} \\ 
			\pcreturn (X,Y)
		   }
		   
		   \procedure[linenumbering]{$\textbf{Oracle } \oracle[OTag]'_\simulator(m)$}{
		   h \gets H(m) \\ 
		   \pcif \exists m' \in \mathcal{Q}: H(m') = h \\ 
		   		\t\t \wedge m \neq m' \pcthen \\ 
				\t (X,Y) \gets (m, m') \\ 
		   \tau \sample \Tag(K, h) \\
		   \mathcal{Q} \gets \mathcal{Q} \cup \{m\} \\  
		   \pcreturn \tau 
		   }
		
	\end{pchstack}

	\end{pcvstack}
	\caption{Adversary $\bdv$ and $\cdv$ for proof of Domain Extension Theorem}
	\label{fig:domain-extension-theorem}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Nonce-based MACs}
\subsubsection{NMAC}
A nonce-based MAC scheme with key space $\mathcal{K}$, nonce space $\mathcal{N}$ and tag space $\mathcal{T}$, consists of a triple of efficient algorithms $(\kgen, \Tag, \verify)$ where 
$$
\begin{aligned}
&\kgen: \{\} \rightarrow \mathcal{K} \\
&\Tag: \mathcal{K} \times \mathcal{N} \times \mathcal{M} \rightarrow \mathcal{T} \\
&\verify: \mathcal{K} \times \mathcal{N} \times \mathcal{M} \times \mathcal{T} \rightarrow \bin \\ 
\end{aligned}
$$
such that
$$
\forall K \in \mathcal{K} \ \forall N \in \mathcal{N} \ \forall m \in \mathcal{M}, \verify(K,N,m, \Tag(K, N, m))
$$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{SUF-CMA Security of NMAC}
A nonce-based MAC scheme is $(q_t, q_v, t, \varepsilon)$-$\seufcma$ secure if for all adversaries $\adv$ running in time at most $t$, making at most $q_t$ tagging queries and at most $q_v$ verification queries, the advantage $\advantage{\seufcma}{\textsc{NMAC}}[(\adv)] \leq \varepsilon$ where 
$$
\advantage{\seufcma}{\textsc{NMAC}}[(\adv)] = \Pr[\textbf{Game } \seufcma \Rightarrow 1]
$$

\begin{figure}[H]
	\begin{pchstack}[ center , boxed,  space=0.5cm]
		\procedure[linenumbering]{$\textbf{Game }\seufcma(\adv, \mac)$}{ 
			K \sample \kgen(1^\lambda) \\
			\mathcal{Q} \gets \emptyset \\ 
			(N^*, m^*, \tau^*) \sample \adv^{\oracle[OTag], \oracle[OVfy]}() \\ 
			 \pcif (N^*, m^*, \tau^*) \in \mathcal{Q} \pcthen \\
			\t \pcreturn 0 \\
			\pcelse \\
			\t b \gets \verify_K(N, m, \tau) \\
			\t \pcreturn b 
		}
	
		\begin{pcvstack}[space=0.3cm]
		\procedure[linenumbering]{$\textbf{Oracle }\oracle[OTag](N, m)$}{ 
			\tau \gets \Tag_K(N, m) \\
			\mathcal{Q} \gets \mathcal{Q} \cup \{(N, m,\tau)\} \\
			\pcreturn \tau 
		}

		\procedure[linenumbering]{$\textbf{Oracle }\oracle[OVfy](N, m, \tau)$}{ 
		b \gets \verify_K(N, m, \tau) \\
		%\mathcal{Q} \gets \mathcal{Q} \cup \{(m,\tau)\} \\
		\pcreturn b
		}
		\end{pcvstack}
	\end{pchstack}
	\caption{SUF-CMA game for $\textsf{NMAC}$}
	\label{fig:sufcma-game-nmac}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{UHF-then-PRF Composition}
\subsubsection{Compose UHF and PRF }
Let $H$ be an $\varepsilon$-UHF with key space $\mathcal{K}$, message space $\mathcal{M}$ and digest space $\mathcal{T}$. Let $F$ be a secure $\prf$ with key space $\mathcal{K}'$, message space $\mathcal{T}$ and output space $\mathcal{X}$. Define a function $F'$ by 
$$
F'((K_1, K_2), m) := F(K_2, H(K_1, m)) 
$$
Then $F'$ is a secure $\prf$ with key space $\mathcal{K} \times \mathcal{K}'$, message space $\mathcal{M}$ and output space $\mathcal{X}$.

\subsubsection{UHF-then-PRF Composition Security}
Let $\adv$ be a PRF adversary against $F'$ making at most $q$ queries, then there exists a PRF adversary $\bdv$ against $F$ making $q$ queries such that 
$$
\advantage{PRF}{F'}[(\adv)] \leq \advantage{PRF}{F}[(\bdv)] + \frac{q^2}{2} \cdot \varepsilon
$$

\begin{proof} 
Let $\adv$ be a $\prf$ adversary against $F'$, we construct a $\prf$ adversary $\bdv$ against $F$ as in Figure \ref{fig:uhf-prf-proof-game}. 
Observe that $\bdv$ makes the same number of queries as $\adv$ does, also $\bdv$ first hashes the query from $\adv$ and then queries the hashes with its oracle $\oracle[RoR]$, which simulates the $\prf$ game that $\adv$ plays. Also, $\bdv$ runs in essentially the same time as $\adv$. Thus $\bdv$ perfectly simulates the $\prf$ game of $\adv$. Observe that $\bdv$ returns the same bit as $\adv$. Thus if $\adv$ wins the game, then $\bdv$ wins the game. 

In the second case, we can construct a UHF adversary $\ddv$ against $H$ as in Figure \ref{fig:uhf-prf-proof-adv-b}. Since $\rho$ is a random function, if we have that $f(H(K_1, m)) = f(H(K_2, m'))$ for $m \neq m'$, then $\ddv$ wins the UHF game. Since $\adv$ makes $q$ queries, there are $\frac{q(q-1)}{2}$ pairs of indices. 

By Union Bound, we have that
$$
\begin{aligned}
\advantage{\prf}{F'}[(\adv)] &\leq \advantage{\prf}{F}[(\bdv)] + \frac{q(q-1)}{2} \cdot \varepsilon \\
&\leq  \advantage{\prf}{F}[(\bdv)] + \frac{q^2}{2} \cdot \varepsilon
\end{aligned}
$$
\end{proof}


\begin{figure}[H]
\begin{pchstack}[center, boxed, space=0.5cm]
\procedure[linenumbering]{$\textbf{Adversary } \bdv^\oracle[RoR] $}{ 
K_1 \sample \mathcal{K} \\ 
b' \sample \adv^\oracle[RoR_\simulator]() \\ 
\pcreturn b' 
}

\procedure[linenumbering]{$\textbf{Oracle }\oracle[RoR_\simulator](m)$}{ 
h \gets H(K_1, m) \\ 
c \gets \oracle[RoR](h) \\ 
\pcreturn c 
}
\end{pchstack}
\caption{Adversary $\bdv$ for UHF-PRF Construction}
\label{fig:uhf-prf-proof-adv-b}
\end{figure}


\begin{figure}[H]
\begin{pchstack}[center, boxed, space=0.5cm]
\procedure[linenumbering]{$\textbf{Adversary } \ddv$}{ 
(X, Y) \gets (\bot, \bot) \\ 
\mathcal{Q} \gets \empty \\ 
K_1 \sample \mathcal{K} \\ 
\rho \sample \mathcal{F}[\mathcal{T}] \\
\adv^{\oracle[OIdeal]}() \\ 
\pcreturn (X, Y)
}
	
\procedure[linenumbering]{$\textbf{Oracle }\oracle[OIdeal](m)$}{ 
h \gets H(K_1, m) \\ 
\pcif \exists m' \in \mathcal{Q}: \\
	\t\t m \neq m' \wedge h = H(K_1, m') \pcthen \\ 
	\t (X,Y) \gets (m, m') \\
c \gets \rho(h) \\ 
\pcreturn c
}
\end{pchstack}
\caption{Adversary $\ddv$ for UHF-PRF Construction}
\label{fig:uhf-prf-proof-game}
\end{figure}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Carter-Wegman (CW) MAC }
\subsubsection{CW-MAC Construction}
Let $H$ be a $\varepsilon$-DUHF with outputs in $\mathcal{T}_H$; Let $F$ be a $\prf$ on $\bin^n$ with output in $\mathcal{T}_H$; assume that $(\mathcal{T}_H, +)$ is a group, define $\textsc{CW}$-$\mac(F,H)$ as follows: 


\begin{figure}[H]
\begin{pchstack}[ center , boxed,  space=0.5cm]
\procedure[linenumbering]{$\kgen(1^\lambda)$}{ 
(K_1, K_2) \sample \mathcal{K}_H \times \mathcal{K}_F \\
\pcreturn (K_1, K_2)
}

\begin{pcvstack}[space=0.3cm]
\procedure[linenumbering]{$\Tag((K_1, K_2), N, m)$}{ 
\tau \gets H(K_1, m) + F(K_2, N) \\
\pcreturn \tau 
}

\procedure[linenumbering]{$\verify((K_1, K_2), N, m, \tau)$}{ 
\tau' \gets \Tag((K_1, K_2), N, m) \\
\pcreturn \tau = \tau' 
}
\end{pcvstack}
\end{pchstack}
\caption{\textsc{CW-MAC} Construction}
\label{fig:cw-mac-construction}
\end{figure}

\subsubsection{CW-MAC Security}
For any $\seufcma$ adversary $\adv$ against $\textsc{CW-MAC}(F,H)$ making $q_t$ tag queries, there exists a $\prf$ adversary $\bdv$ against $F$ such that 
$$
\advantage{\seufcma}{\textsc{CW-MAC}(F,H)}[(\adv)] \leq \advantage{\prf}{F}[(\bdv)] + \varepsilon + \frac{1}{|\mathcal{T}_H|}
$$

\begin{proof}
Since we have that $\Tag$ is deterministic, it suffices to show the no-verify EUF-CMA security. Define $\mathrm{G}_0$ and $\mathrm{G}_1$ as in Figure \ref{fig:cw-mac-security}. Let $W_i$ be the event that $\adv$ wins in game $\mathrm{G}_i$ respectively. We have that 

$$
\advantage{\seufcma}{\textsc{CW-MAC}(F,H)}[(\adv)] \leq \abs{\Pr[W_0] - \Pr[W_1]} + \Pr[W_1]
$$

We construct a $\prp$ adversary $\bdv$ against $F$ as in Figure \ref{fig:cw-mac-security}. Observe that $\bdv$ makes the same number of queries as $\adv$, and $\bdv$ samples the a hash key and run $H(K_1, m)$ with $m$ from $\adv$, queries its oracle $\oracle[RoR]$ with the nonce queried by $\adv$, and then output the tag after group operation, which simulates the $\seufcma$ game that $\adv$ plays. By Advantage Rewriting Lemma, we have that 
$$
\begin{aligned}
\advantage{\prf}{F}[(\bdv)] 
&= \abs{\Pr[b'=0 \mid b = 0] - \Pr[b'=0 \mid b=1]} \\ 
&= \abs{\Pr[W_0] - \Pr[W_1]}
\end{aligned}
$$

We then show that $\Pr[W_1] \leq \varepsilon + \frac{1}{|\mathcal{T}_H|}$. Let $E_1$ denote the event that $\adv$ wins and output a triple $(N^*, m^*, \tau^*)$ in which $N^*$ has neven been used in any of $\adv$'s tag queries. Let $E_2$ denote the event that $\adv$ wins and output a triple $(N^*, m^*, \tau^*)$ in which $N^* = N$ with $N$ repeated from some previous tag query. We claim that 
$$
\Pr[W_1] = \Pr[E_1] + \Pr[E_2] 
$$

In $E_1$, for $\adv$ to win, we must have $\tau^* = H(K_1, m^*) + f(N^*)$. Note that after rearranging, we have that $f(N^*)$ is a group element in $\mathcal{T}_H$. Since $N^*$ is new, $f(N^*)$ is uniformly random in $\mathcal{T}_H$ and independent from all the other outputs of $f$ seen by $\adv$. Thus we have that 
$$
\Pr[E_1] = \frac{1}{|\mathcal{T}_H|}
$$ 

In $E_2$, we then have $\tau^* = H(K_1, m^*) + f(N)$ and $\tau = H(K_1, m) + f(N)$ for some $N$. Thus we have that $\tau^* - \tau = H(K_1, m^*) - H(K_1, m)$. We can then build an adversary $\ddv$ that breaks DUHF security of $H$ with output $(m^*, m, \tau^* - \tau)$. Thus we have that 
$$
\Pr[E_2] \leq \advantage{DUHF}{H}[(\ddv)] \leq \varepsilon
$$

Finally, we have that 

$$
\begin{aligned}
\advantage{\seufcma}{\textsc{CW-MAC}(F,H)}[(\adv)] 
&\leq \abs{\Pr[W_0] - \Pr[W_1]} + \Pr[W_1] \\ 
&= \advantage{\prp}{F}[(\bdv)] + \varepsilon + \frac{1}{|\mathcal{T}_H|}
\end{aligned}
$$


\end{proof}



\begin{figure}[H]
	\begin{pchstack}[ center , boxed, space=0.5cm]
	\procedure[linenumbering]{$\textbf{Game } \mathrm{G}_0 \ \gamechange{$\mathrm{G_1}$} $}{ 
	(K_1, K_2) \sample \kgen(1^\lambda) \\
	\gamechange{$\rho \sample \mathcal{F}[\bin^n]$} \\ 
	\mathcal{Q} \gets \emptyset \\ 
	(N^*, m^*, \tau^*) \sample \adv^{\oracle[OTag]}() \\ 
	\pcif m^* \in \mathcal{Q} \pcthen \\ 
		\t \pcreturn 0 \\ 
	\pcelse \\ 
		\t \tau' \gets H(K_1, m^*) + F(K_2, N^*) \\ 
		\t \gamechange{$\tau' \gets H(K_1, m^*) + f(N^*)$} \\ 
		\pcreturn \tau^* = \tau' 
	}
	
	\begin{pcvstack}[space=0.3cm]
	\procedure[linenumbering]{$\textbf{Oracle } \oracle[OTag](N, m) $}{ 
	\tau \gets H(K_1, m) + F(K, N) \\
	\gamechange{$\tau \gets H(K_1, m) + f(N)$} \\ 
	\mathcal{Q} \gets \mathcal{Q} \cup \{m\} \\
	\pcreturn \tau 
	}
	
	\procedure[linenumbering]{$\textbf{Oracle } \oracle[OTag]_\simulator(N, m)$}{
	c \gets \oracle[RoR](N) \\ 
	\tau \gets H(K_1, m) + c \\ 
	\pcreturn \tau 
	}
	\end{pcvstack}
	
	\procedure[linenumbering]{$\textbf{Adversary } \bdv^\oracle[RoR]$}{ 
		K_1 \sample \mathcal{K}_H \\ 
		(N^*, m^*, \tau^*) \sample \adv^{\oracle[OTag]_\simulator}()\\ 
		c' \gets \oracle[RoR](m^*) \\ 
		\tau' \gets H(K_1, m^*) + c' \\ 
		\pcif \tau^* = \tau' \pcthen \\
		\t \pcreturn 0 \\ 
		\pcelse \\ 
		\t \pcreturn 1 
	}
	
	\end{pchstack}
	\caption{Security Proof of MAC construction from PRF}
	\label{fig:cw-mac-security}
	\end{figure}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Asymmetric Encryption}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Public Key Encryption}
\subsubsection{Public Key Encryption Scheme}
A \textit{public key encryption} scheme $\textsc{PKE}$ with public key space $\mathcal{PK}$, secret key space $\mathcal{SK}$, message space $\mathcal{M}$, and ciphertext space $\mathcal{C}$, consists of a triple of efficient algorithms $\textsc{PKE} = (\kgen, \enc, \dec)$ where 
$$
\begin{aligned}
&\kgen: \{\} \rightarrow \mathcal{PK} \times \mathcal{SK} \\
&\enc: \mathcal{PK} \times \mathcal{M} \rightarrow \mathcal{C} \\ 
&\dec: \mathcal{SK} \times \mathcal{C} \rightarrow \mathcal{M} \cup \{\bot\} 
\end{aligned}
$$
such that 
$$
\forall (\pk, \sk) \in \mathcal{PK} \times \mathcal{SK} \ \forall m \in \mathcal{M}, \dec(\sk, \enc(\pk, m)) = m
$$



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{$\indcca$ security of PKE}
A public key encryption scheme  $\PKE$ is defined to be $(q_e, q_d, t,\varepsilon)$-\textit{indistinguishibility under chosen ciphertext attack} ($\indcca)$, if for any adversaries $\adv$ running in time at most $t$ and making at most $q_e$ encryption queries to oracle $\oracle[LoR]$ and at most $q_d$ decryption queries to oracle $\oracle[ODec]$, the advantage $\advantage{\indcpa}{\PKE}[(\adv)] \leq \varepsilon$.

$$
\advantage{\indcca}{\PKE}[(\adv)] = 2 \cdot | \Pr[\textbf{Game } \indcca(\adv, \SE) \Rightarrow \true ] - \frac{1}{2} | 
$$ 


\begin{figure}[H]
\begin{pchstack}[ center , boxed, space=0.5cm]
\procedure[linenumbering]{$\textbf{Game }\indcca(\adv, \PKE)$}{ 
b \sample \bin \\
\pk, \sk \sample \kgen(1^\lambda) \\ 
\mathcal{Q} \gets \emptyset  \\
b' \sample \adv^{\oracle[LoR], \oracle[ODec] }(\pk) \\
\pcreturn b'= b
 }

\procedure[linenumbering]{$\textbf{Oracle }\oracle[LoR](m_0, m_1)$}{
	\pcif |m_0| \neq |m_1| \pcthen \\ 
	\t \pcreturn \bot \\  
	c \sample \enc(\pk, m_b) \\
	\mathcal{Q} \gets \mathcal{Q} \cup \{c\}  \\
	\pcreturn c
}
	   
\procedure[linenumbering]{$\textbf{Oracle }\oracle[ODec](c)$}{ 
\pcif c \in \mathcal{Q} \pcthen \\ 
	\t \pcreturn \bot \\ 
m \gets \dec(\sk, c) \\ 
\pcreturn m
}
\end{pchstack}
\caption{IND-CCA Game of a Public Key Encryption Scheme}
\label{fig:indcca-game-pke}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{KEM and DEM}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Key Encapsulation Mechanism}
A \textit{key encapuslation mechanism} $\KEM$ with public key space $\mathcal{PK}$, secret key space $\mathcal{SK}$, symmetric key space $\mathcal{K}$, and encapsulation space $\mathcal{C}$, consists of a triple of efficient algorithms $\KEM = (\kgen, \textsc{Encap}, \textsc{Decap})$ where 
$$
\begin{aligned}
&\kgen: \{\} \rightarrow \mathcal{SK} \times \mathcal{PK} \\ 
&\textsc{Encap}: \mathcal{PK} \rightarrow  \mathcal{C} \times \mathcal{K} \\ 
&\textsc{Decap}: \mathcal{SK} \times \mathcal{C} \rightarrow \mathcal{K} \cup \{\bot\} 
\end{aligned}
$$
such that
$$
\forall (\sk, \pk) \in \mathcal{SK} \times \mathcal{PK}, \textsc{Encap}(\pk) = (c, K) \Rightarrow K = \textsc{Decap}(\sk, c)
$$


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{$\indcca$ Security for KEM}
A key encapsulation mechanism  $\KEM$ is defined to be $(q_e, q_d, t,\varepsilon)$-\textit{indistinguishibility under chosen ciphertext attack} ($\indcca)$, if for any adversaries $\adv$ running in time at most $t$ and making at most $q_e$ encryption queries to oracle $\oracle[LoR]$ and at most $q_d$ decryption queries to oracle $\oracle[ODec]$, the advantage $\advantage{\indcpa}{\KEM}[(\adv)] \leq \varepsilon$.

$$
\advantage{\indcca}{\KEM}[(\adv)] = 2 \cdot | \Pr[\textbf{Game } \indcca(\adv, \KEM) \Rightarrow \true ] - \frac{1}{2} | 
$$ 


\begin{figure}[H]
\begin{pchstack}[ center , boxed, space=0.5cm]
\procedure[linenumbering]{$\textbf{Game }\indcca(\adv, \KEM)$}{ 
b \sample \bin \\
\pk, \sk \sample \kgen(1^\lambda) \\ 
(c_0, K_0) \sample \textsc{Encap}(\pk) \\ 
K_1 \sample \mathcal{K} \\ 
b' \sample \adv^{\oracle[ODec] }(\pk, c_0, K_b) \\
\pcreturn b'= b
}
	   
\procedure[linenumbering]{$\textbf{Oracle }\oracle[ODec](c)$}{ 
\pcif c = c_0 \pcthen \\ 
	\t \pcreturn \bot \\ 
K \gets \textsc{Decap}(\sk, c) \\ 
\pcreturn K
}
\end{pchstack}
\caption{IND-CCA Game of a Public Key Encryption Scheme}
\label{fig:indcca-game-kem}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{KEM/DEM Composition}
Let $\textsc{KEM} = (\kgen, \textsc{Encap}, \textsc{Decap})$, and $\textsc{DEM} = (\kgen, \enc, \dec)$ be a \textsc{DEM} such that $\textsc{KEM}.\mathcal{K} = \textsc{DEM}.\mathcal{K}$, then we build a PKE scheme $\PKE = (\kgen, \enc, \dec)$ from $\KEM$ and \textsc{DEM} as in Figure \ref{fig:kemdem-composition}.

\begin{figure}[H]
\begin{pchstack}[ center , boxed, space=0.5cm]
\procedure[linenumbering]{$\PKE.\kgen$}{ 
\sk, \pk \sample \KEM.\kgen \\ 
\pcreturn (\sk, \pk)
}
		
\procedure[linenumbering]{$\PKE.\enc(m)$}{ 
(c_K, K) \sample \KEM.\textsc{Encap}(\pk) \\ 
c_m \sample \textsc{DEM}.\enc(K, m) \\ 
\pcreturn c_K||c_m
}
			
\procedure[linenumbering]{$\PKE.\dec(\sk, c)$}{ 
c_K || c_m \gets c \\ 
K \gets \KEM.\textsc{Decap}(\sk, c_K) \\ 
\pcif K = \bot \pcthen \\
	\t \pcreturn \bot \\ 
m \gets \textsc{DEM}.\dec(K, c_m) \\
\pcreturn m
}
\end{pchstack}
\caption{KEM/DEM Composition}
\label{fig:kemdem-composition}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Security of KEM/DEM Composition}
For any 1-query $\indcca$ adversary $\adv$ against $\PKE$ from KEM/DEM composition, there exist adversaries $\bdv$ and $\cdv$ such that
$$
\advantage{\indcca}{\PKE}[(\adv)] \leq 2 \cdot \advantage{\indcca}{\KEM}[(\bdv)] + \advantage{\indcca}{\textsc{DEM}}[(\cdv)]
$$



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{RSA Encryption}
\subsubsection{Textbook RSA}
Define the textbook RSA cryptosystem as in Figure \ref{fig:textbook-rsa}.  

\begin{figure}[H]
\begin{pchstack}[ center , boxed, space=0.5cm]
\procedure[linenumbering]{$\kgen(\ell)$}{ 
p, q \sample \textsf{Prime}(\ell/2) \\
\t \pccomment{$p,q$ of bit-size $\ell /2$} \\
N \gets p \cdot q \\ 
d \sample \ZZ_N^* \\ 
e \gets d^{-1} \bmod{\phi(N)} \\ 
\pk \gets (e, N) \\ 
\sk \gets d \\ 
\pcreturn (\pk, \sk)
}
	
\begin{pcvstack}[space = 0.3cm]
\procedure[linenumbering]{$\enc(\pk, m)$}{ 
(e, N) \gets \pk \\ 
c \gets m^e \bmod{N} \\ 
\pcreturn c
}
		
\procedure[linenumbering]{$\dec(\sk, c)$}{ 
d \gets \sk \\ 
m \gets c^d \bmod{N} \\ 
\pcreturn m
}
\end{pcvstack}
\end{pchstack}
\caption{Textbook RSA}
\label{fig:textbook-rsa}
\end{figure}

By Euler's Theorem, the correctness is defined by:
$$
(m^e)^d \equiv m^{k \cdot \phi(N) + 1} \equiv m^{k \cdot \phi(N)} \cdot m \equiv m \pmod{N}
$$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{RSA inversion Problem}
Define the \textit{RSA Inversion Problem} as in Figure \ref{fig:rsa-inv}. 
\begin{figure}[H]
\begin{pchstack}[ center , boxed, space=0.5cm]
\procedure[linenumbering]{$\textbf{Game } \textsc{RSAInv}(\adv)$}{ 
\sk, \pk \sample \textsc{RSA}.\kgen \\ 
d \gets \sk \\ 
e, N \gets \pk \\ 
x \sample \ZZ_N \\ 
y \gets x^e \bmod{N} \\ 
x' \gets \adv(N, e, y) \\ 
\pcreturn x = x'  
}
\end{pchstack}
\caption{RSA Inversion Problem}
\label{fig:rsa-inv}
\end{figure}

\textit{Remarks}: 
\begin{enumerate}[(1)]
\item If $\adv$ can factor $N$, then $\adv$ can solve the RSA inversion problem. 
\item The reverse implicaion is open, but no algorithm faster than factoring $N$ is known for solving RSA inversion in general. 
\end{enumerate}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Build KEM from RSA}
Let $H: \ZZ_N \rightarrow \bin^k$ be a hash function. We can build a KEM from RSA as in Figure \ref{fig:rsa-kem}. 

\begin{figure}[H]
\begin{pchstack}[ center , boxed, space=0.5cm]
\procedure[linenumbering]{$\kgen(\ell)$}{ 
p, q \sample \textsf{Prime}(\ell/2) \\
\t \pccomment{$p,q$ of bit-size $\ell /2$} \\
N \gets p \cdot q \\ 
d \sample \ZZ_N^* \\ 
e \gets d^{-1} \bmod{\phi(N)} \\ 
\pk \gets (e, N) \\ 
\sk \gets d \\ 
\pcreturn (\pk, \sk)
}
		
\begin{pcvstack}[space = 0.3cm]
\procedure[linenumbering]{$\textsc{Encap}(\pk, m)$}{ 
(e, N) \gets \pk \\ 
s \gets \ZZ_N \\ 
c \gets s^e \bmod{N} \\ 
K \gets H(s) \\
\pcreturn (c, K) 
}
			
\procedure[linenumbering]{$\textsc{Decap}(\sk, c)$}{ 
d \gets \sk \\ 
s \gets c^d \bmod{N} \\ 
K \gets H(s) \\
\pcreturn K
}
\end{pcvstack}
\end{pchstack}
\caption{Build KEM from RSA}
\label{fig:rsa-kem}
\end{figure}

\textit{Remarks}: 
\begin{enumerate}
\item RSA-KEM is $\indcca$ secure under Random Oracle Model (ROM) provided RSA inversion problem is hard.  
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Discrete Log Setting}
\subsubsection{DLog Problem}
Let $p,q$ be primes such that $p = kq + 1$ for some $k \in \ZZ^+$. Let $\GG$ be a subgroup of $\ZZ_p^*$ such that $\GG = \Angle{g}$ for some geneator $g$ and $|\GG| = q$. Define the \textit{discrete log problem} (DLP) as in Figure \ref{fig:dlog}.

\begin{figure}[H]
\begin{pchstack}[ center , boxed, space=0.5cm]
\procedure[linenumbering]{$\textbf{Game } \textsc{DLog}(\adv)$}{ 
x \sample \ZZ_q \\ 
x' \gets \adv(g, g^x) \\ 
\pcreturn x = x' 
}
\end{pchstack}
\caption{Discrete Log Problem}
\label{fig:dlog}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{CDH Problem}
Let $p,q$ be primes such that $p = kq + 1$ for some $k \in \ZZ^+$. Let $\GG$ be a subgroup of $\ZZ_p^*$ such that $\GG = \Angle{g}$ for some geneator $g$ and $|\GG| = q$. Define the \textit{computational Diffie-Hellman problem} (CDH) as in Figure \ref{fig:cdh}.

\begin{figure}[H]
\begin{pchstack}[ center , boxed, space=0.5cm]
\procedure[linenumbering]{$\textbf{Game } \textsc{CDH}(\adv)$}{ 
x,y \sample \ZZ_q \\ 
Z \gets \adv(g, g^x, g^y) \\ 
\pcreturn Z = g^{ab}
}
\end{pchstack}
\caption{Computational Diffie-Hellman Problem}
\label{fig:cdh}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{DDH Problem}
Let $p,q$ be primes such that $p = kq + 1$ for some $k \in \ZZ^+$. Let $\GG$ be a subgroup of $\ZZ_p^*$ such that $\GG = \Angle{g}$ for some geneator $g$ and $|\GG| = q$. Define the \textit{Decisional Diffie-Hellman problem} (DDH) as in Figure \ref{fig:ddh}.

\begin{figure}[H]
\begin{pchstack}[ center , boxed, space=0.5cm]
\procedure[linenumbering]{$\textbf{Game } \textsc{DDH}(\adv)$}{ 
b \sample \bin \\ 
x,y,z \sample \ZZ_q \\   
Z_0 \gets g^{ab} \\ 
Z_1 \gets g^c \\ 
b' \gets \adv(g, g^x, g^y, Z_b) \\ 
\pcreturn b = b'
}
\end{pchstack}
\caption{Decisional Diffie-Hellman Problem}
\label{fig:ddh}
\end{figure}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Diffie-Hellman Key Exchange}
Let $p,q$ be primes such that $p = kq + 1$ for some $k \in \ZZ^+$. Let $\GG$ be a subgroup of $\ZZ_p^*$ such that $\GG = \Angle{g}$ for some geneator $g$ and $|\GG| = q$. Define the \textit{Diffie-Hellman Key Exchange} as in Figure \ref{fig:dhke}.


\begin{figure}[H]
\begin{pchstack}[boxed, center]
\pseudocode{
\textbf{Alice} \<\< \textbf{Bob}
\\[0.1\baselineskip][\hline]\<\< \\[-0.5\baselineskip]
a \sample \ZZ_q \<\< \\
K_a \gets g^a  \< \sendmessageright*[1.5cm]{K_a} \< \\
\<\< \pcif K_a^q \neq 1 \pcthen \\
\<\<  \t  \pcreturn \bot \\ 
\<\< b \sample \ZZ_q \\ 
\< \sendmessageleft*[1.5cm]{K_b} \< K_b \gets g^b \\
\pcif K_b^q \neq 1 \pcthen \\
\t \pcreturn \bot \\ 
K \gets \textsc{KDF}(K_b^a) \<\< K \gets \textsc{KDF}(K_a^b)
} 
\end{pchstack}
\caption{Diffie-Hellman Key Exchange}
\label{fig:dhke}
\end{figure}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{ElGamal Encryption}
Let $p,q$ be primes such that $p = kq + 1$ for some $k \in \ZZ^+$. Let $\GG$ be a subgroup of $\ZZ_p^*$ such that $\GG = \Angle{g}$ for some geneator $g$ and $|\GG| = q$. Define the \textit{ElGamal Public-Key Encryption Scheme} as in Figure \ref{fig:ElGamal}


\begin{figure}[H]
\begin{pchstack}[ center , boxed, space=0.5cm]
\procedure[linenumbering]{$\kgen(\ell)$}{ 
x \sample \ZZ_q \\ 
X \gets g^x \\ 
\pk \gets X \\ 
\sk \gets x
}
		

\procedure[linenumbering]{$\enc(\pk, M)$}{ 
X \gets \pk \\ 
r \sample \ZZ_q \\ 
R \gets g^r \\ 
Z \gets X^r \\
C \gets M \cdot Z \\   
\pcreturn (R, C)
}
			
\procedure[linenumbering]{$\dec(\sk, R, C)$}{ 
x \gets \sk \\ 
\pcif R^q \neq 1 \pcthen \\
	\t \pcreturn \bot \\ 
Z \gets R^x \\ 
M \gets C \cdot Z^{-1} \\ 
\pcreturn M
}
\end{pchstack}
\caption{ElGamal Public Key Encryption}
\label{fig:ElGamal}
\end{figure}

The correctness is defined by: 
$$
M \cdot X^r \cdot R^{-x} = M \cdot g^{xr} \cdot g^{-rx} = M 
$$


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{DHIES}
Let $p,q$ be primes such that $p = kq + 1$ for some $k \in \ZZ^+$. Let $\GG$ be a subgroup of $\ZZ_p^*$ such that $\GG = \Angle{g}$ for some geneator $g$ and $|\GG| = q$. Let $H$ be a hash function with suitable output domain. Let $\textsc{AE}$ be an authenticated encryption scheme. Define the \textit{Diffie-Hellman Integrated Encryption Scheme} (DHIES) as in Figure \ref{fig:DHIES}. 

\begin{figure}[H]
\begin{pchstack}[ center , boxed, space=0.5cm]
\procedure[linenumbering]{$\kgen(\ell)$}{ 
x \sample \ZZ_q \\ 
X \gets g^x \\ 
\pk \gets X \\ 
\sk \gets x
}
			
\procedure[linenumbering]{$\enc(\pk, M)$}{ 
X \gets \pk \\ 
r \sample \ZZ_q \\ 
R \gets g^r \\ 
Z \gets X^r \\    
K \gets H(X, R, Z) \\ 
K_e, K_m \gets K \\ 
C \gets \textsc{AE}.\enc(K_e, K_m, M) \\ 
\pcreturn (R, C)
}

\procedure[linenumbering]{$\dec(\sk, R, C)$}{ 
x \gets \sk \\ 
\pcif R^q \neq 1 \pcthen \\
	\t \pcreturn \bot \\ 
X \gets g^x \\ 
Z \gets R^x \\ 
K \gets H(X, R, Z) \\ 
K_e, K_m \gets K \\ 
M \gets \textsc{AE}.\dec(K_e, K_m, C) \\ 
\pcreturn M
}

\end{pchstack}
\caption{Diffie-Hellman Intergrated Encryption Scheme}
\label{fig:DHIES}
\end{figure}

\textit{Remarks}:
\begin{enumerate}
\item DHIES is $\indcca$ secure under Random Oracle Model.  
\end{enumerate}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Digital Signature
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Digital Signature}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Digital Signature Scheme}
A signature scheme $\sig$ with signing key space $\mathcal{SK}$, verification key space $\mathcal{VK}$, message space $\mathcal{M}$, and signature space $\Sigma$ consists of a triple algorithm $(\kgen, \sig, \verify)$ where 
$$
\begin{aligned}
&\kgen: \{\} \to \mathcal{SK} \times \mathcal{VK} \\
&\sig: \mathcal{SK} \times \mathcal{M} \to \Sigma \\ 
&\verify: \mathcal{VK} \times \Sigma \times \mathcal{M} \to \bin 
\end{aligned}
$$
such that 
$$
\forall m \in \mathcal{M} \ \forall (sk, vk) \in \mathcal{SK} \times \mathcal{VK}, \verify(vk, \sig(sk, m), m) = 1
$$

\subsection{Signature Unforgeability}
\subsubsection{EUF-CMA Security}
A signature scheme is $(q_s, t, \varepsilon)$-\textit{existential unforgeability under chosen message attack} ($\eufcma$) secure, if for any adversaries making $q_s$ queries to signing oracle $\oracle[OSig]$, and running in time at most $t$, the advantage $\advantage{\eufcma}{\mac}[(\adv)] \leq \varepsilon$ where 
$$
\advantage{\eufcma}{\sig}[(\adv)] = \Pr[\textbf{Game } \eufcma(\sig, \adv) \Rightarrow 1]
$$

\begin{figure}[H]
\begin{pchstack}[ center , boxed, space=0.5cm]
\procedure[linenumbering]{$\textbf{Game }\eufcma(\adv, \sig)$}{ 
vk, sk \sample \kgen(1^\lambda) \\
\mathcal{Q} \gets \emptyset \\ 
(m^*, \sigma^*) \sample \adv^{\oracle[OSig]}() \\ 
\pcif m^* \in \mathcal{Q} \pcthen \\
	\t \pcreturn 0 \\
\pcelse \\
	\t b \gets \verify(pk, m, \sigma) \\
	\t \pcreturn b 
}
	
\procedure[linenumbering]{$\textbf{Oracle }\oracle[OSig](m)$}{ 
\sigma \gets \sig(sk, m) \\
\mathcal{Q} \gets \mathcal{Q} \cup \{m\} \\
\pcreturn \sigma 
}
\end{pchstack}
\caption{EUF-CMA Game for $\sig$}
\label{fig:eufcma-game-sig}
\end{figure}


\subsubsection{SUF-CMA Security}
A signature scheme is $(q_s, t, \varepsilon)$-\textit{strong existential unforgeability under chosen message attack} ($\seufcma$) secure, if for any adversaries making $q_s$ queries to signing oracle $\oracle[OSig]$, and running in time at most $t$, the advantage $\advantage{\seufcma}{\mac}[(\adv)] \leq \varepsilon$ where 
$$
\advantage{\seufcma}{\sig}[(\adv)] = \Pr[\textbf{Game } \seufcma(\sig, \adv) \Rightarrow 1]
$$

\begin{figure}[H]
\begin{pchstack}[ center , boxed, space=0.5cm]
\procedure[linenumbering]{$\textbf{Game }\seufcma(\adv, \sig)$}{ 
vk, sk \sample \kgen(1^\lambda) \\
\mathcal{Q} \gets \emptyset \\ 
(m^*, \sigma^*) \sample \adv^{\oracle[OSig]}() \\ 
\pcif (m^*, \sigma^*) \in \mathcal{Q} \pcthen \\
	\t \pcreturn 0 \\
\pcelse \\
	\t b \gets \verify(pk, m, \sigma) \\
	\t \pcreturn b 
}
	
\procedure[linenumbering]{$\textbf{Oracle }\oracle[OSig](m)$}{ 
\sigma \gets \sig(sk, m) \\
\mathcal{Q} \gets \mathcal{Q} \cup \{m, \sigma \} \\
\pcreturn \sigma 
}
\end{pchstack}
\caption{SUF-CMA Game for $\sig$}
\label{fig:sufcma-game-sig}
\end{figure}



\end{document}


